<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GeekPlux</title>
  <subtitle>知行合一</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://geekplux.com/"/>
  <updated>2017-07-09T10:29:56.000Z</updated>
  <id>http://geekplux.com/</id>
  
  <author>
    <name>GeekPlux</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>D3 force layout and WebGL integration</title>
    <link href="http://geekplux.com/2017/06/27/d3-force-and-webgl-integration.html"/>
    <id>http://geekplux.com/2017/06/27/d3-force-and-webgl-integration.html</id>
    <published>2017-06-27T11:57:37.000Z</published>
    <updated>2017-07-09T10:29:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>D3 是目前最流行的数据可视化库，WebGL 是目前 Web 端最快的绘制技术。由于性能问题的局限，将两者结合的尝试越来越多（如），本文将尝试用 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">D3 的力导向图</a> 和 <a href="https://github.com/mrdoob/three.js/" target="_blank" rel="external">Three.js</a> 和 <a href="https://github.com/pixijs/pixi.js" target="_blank" rel="external">PixiJS</a> 结合。全文阅读完大概 5 分钟，因为你重点应该看<a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">代码</a>。</p>
</blockquote>
<p>做数据可视化时，必然会考虑<strong>性能</strong>的问题。早前数据可视化都是用 Qt 等 GUI，后来逐渐迁移到了迅猛发展的浏览器上展示，Web 的性能问题成了大多数可视化的局限，尤其是在三维可视化，或数据量特别大的时候。现在主流的 Web 可视化技术为三种：SVG、Canvas 和 WebGL，难易程度和性能如下图：</p>
<p><img src="https://ooo.0o0.ooo/2017/07/09/59610ee72e616.png" alt="Web visualization tech"></p>
<p>SVG 的优点很多，编辑简单，交互便捷，灵活性极高，业内成熟的可视化工具（如 d3）都是用的 SVG。但是每个 SVG 都是一个 DOM 元素，随着它的数量上来之后，交互开始慢的难以忍受。这是因为每当修改一个 DOM 对象，只要这个对象在文档里，接着在浏览器里就会发生两个动作，一个叫 <strong>Reflow（重排，就是重新排版）</strong>，另一个叫 <strong>Repaint（重绘，就是重新渲染页面）</strong>。这两个动作不一定都会发生，但如果被修改的 DOM 当前可见的话，那么就会先重排，后重绘。绘制性能上 canvas 和 SVG（DOM 元素）应该差不多，但前者可以省掉重排过程，因此性能更高。然而，WebGL 的性能更胜一筹，因为 WebGL 使用 GPU 加速渲染，GPU 在大规模计算方面有绝对优势（图像处理、深度学习都在用，显卡已经卖疯了）。例子：用 WebGL 绘制 200000 个点的动画(<a href="http://rickyreusser.com/smoothly-animating-points-with-regl/" target="_blank" rel="external">http://rickyreusser.com/smoothly-animating-points-with-regl/</a>)</p>
<p>WebGL 虽然威力无穷，但是写起来比较痛苦，画个三角形大致要 100 行代码。所以很多人对 WebGL 进行了封装。上面图中提到的两个 <a href="https://github.com/mrdoob/three.js/" target="_blank" rel="external">Three.js</a> 和 <a href="https://github.com/pixijs/pixi.js" target="_blank" rel="external">PixiJS</a> 是目前最流行的两款 WebGL 库，当然还有新兴的 <a href="https://github.com/regl-project/regl" target="_blank" rel="external">regl</a> 在今年的 <a href="https://openvisconf.com/" target="_blank" rel="external">OpenVis</a> 上大放异彩。本文尝试用前两者和 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a> 结合（<a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">项目代码在此</a>），后面如果有时间的话，我会把使用 regl 和原生 WebGL 的例子也补充进去（我知道这是个 flag）。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>首先我们要知道什么是<strong>力导向图</strong>和如何使用 <a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a>。d3 4.0 之后，作者将其模块化，force 这个模块是基于 <a href="https://en.wikipedia.org/wiki/Verlet_integration" target="_blank" rel="external">velocity Verlet</a> 实现了物理粒子之间的作用力的仿真，常用于网络或关系结构数据。即你把网络中的节点想象成一个个粒子，它们之间互相有作用力，所以不停的拉扯，直到趋于一个稳定状态，具体可以看我 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">demo</a> 中可视化出来的样子。</p>
<p><img src="https://ooo.0o0.ooo/2017/07/09/59610ee4d02d5.png" alt="Demo 效果图"></p>
<p>仔细看 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo" target="_blank" rel="external">demo</a> 中的源码可以发现，用 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo/blob/master/src/three.js" target="_blank" rel="external">three.js</a> 和用 <a href="https://github.com/geekplux/d3-force-webgl-integration-demo/blob/master/src/pixi.js" target="_blank" rel="external">pixi.js</a> 实现起来非常类似，其中有关力导向图的关键代码是下面几句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> simulation = d3.forceSimulation() <span class="comment">// 创建一个作用力的仿真，但此时还没启动</span></div><div class="line">  .force(<span class="string">'link'</span>, d3.forceLink().id((d) =&gt; d.id)) <span class="comment">// 为边之间添加 Link 型作用力</span></div><div class="line">  .force(<span class="string">'charge'</span>, d3.forceManyBody()) <span class="comment">// 指定节点间的作用力类型为 Many-Body 型</span></div><div class="line">  .force(<span class="string">'center'</span>, d3.forceCenter(width / <span class="number">2</span>, height / <span class="number">2</span>)) <span class="comment">// Centering 作用力指定布局围绕的中心</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/d3/d3-force/" target="_blank" rel="external">d3-force</a> 提供了五种作用力，分别是 Centering、Collision、Links、Many-Body、Positioning。此时我们已经创建好带有各种力的仿真器了，接下来需要启动它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">simulation</div><div class="line">  .nodes(data.nodes) <span class="comment">// 根据 data.nodes 数组来计算点之间的作用力，相当于不停计算节点的 xy 坐标</span></div><div class="line">  .on(<span class="string">'tick'</span>, ticked) <span class="comment">// 每次 tick 调用 ticked</span></div><div class="line"></div><div class="line">simulation.force(<span class="string">'link'</span>)</div><div class="line">  .links(data.links) <span class="comment">// 根据 data.links 数据计算边之间的作用力</span></div></pre></td></tr></table></figure>
<p>至此一个力导向图的仿真就开始了，那么怎么把这些节点和边显示出来呢？让我们继续看源码，以 three.js 为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> THREE.Scene()</div><div class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> THREE.OrthographicCamera(<span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</div><div class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> THREE.WebGLRenderer(&#123;alpha: <span class="literal">true</span>&#125;)</div><div class="line">renderer.setSize(width, height)</div><div class="line">container.appendChild(renderer.domElement) <span class="comment">// container 这里是 document.body</span></div></pre></td></tr></table></figure>
<p>在 Three.js 中展示场景需要具备三要素：<strong>场景、照相机、渲染器</strong>。照相机就相当于我们的眼睛，它对着渲染好的场景就相当于把场景成像到了相机中，这里的照相机我们用的是平行投影相机，渲染器我们使用的是 WebGL 渲染器。设置好渲染器的大小，把它添加到页面的元素上，相当于添加了一个 <code>&lt;canvas&gt;</code> 元素。接下来，我们生成每个节点和边的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">data.nodes.forEach((node) =&gt; &#123;</div><div class="line">  node.geometry = <span class="keyword">new</span> THREE.CircleBufferGeometry(<span class="number">5</span>, <span class="number">32</span>)</div><div class="line">  node.material = <span class="keyword">new</span> THREE.MeshBasicMaterial(&#123; color: colour(node.id) &#125;)</div><div class="line">  node.circle = <span class="keyword">new</span> THREE.Mesh(node.geometry, node.material)</div><div class="line">  scene.add(node.circle)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">data.links.forEach((link) =&gt; &#123;</div><div class="line">  link.material = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; color: <span class="number">0xAAAAAA</span> &#125;)</div><div class="line">  link.geometry = <span class="keyword">new</span> THREE.Geometry()</div><div class="line">  link.line = <span class="keyword">new</span> THREE.Line(link.geometry, link.material)</div><div class="line">  scene.add(link.line)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>套路都一样，都是先建一个几何体，然后设置材质的样式，添加到场景中就好了。接下来只要在刚才提到的 ticked 这个回调函数中把节点和边的坐标更新一下就好了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ticked</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  data.nodes.forEach((node) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> &#123; x, y, circle &#125; = node</div><div class="line">    circle.position.set(x, y, <span class="number">0</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  data.links.forEach((link) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> &#123; source, target, line &#125; = link</div><div class="line">    line.geometry.verticesNeedUpdate = <span class="literal">true</span></div><div class="line">    line.geometry.vertices[<span class="number">0</span>] = <span class="keyword">new</span> THREE.Vector3(source.x, source.y, <span class="number">-1</span>)</div><div class="line">    line.geometry.vertices[<span class="number">1</span>] = <span class="keyword">new</span> THREE.Vector3(target.x, target.y, <span class="number">-1</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  render(scene, camera)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是比想象的简单多了？如果以上有什么地方看不懂，说明你可能对 Three.js 不是很了解，不过没关系，它的文档写的很好，入门很快。希望这篇文章能给你带来一些帮助，做了点微小的贡献，很惭愧 :)</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;D3 是目前最流行的数据可视化库，WebGL 是目前 Web 端最快的绘制技术。由于性能问题的局限，将两者结合的尝试越来越多（如），本文将尝试用 &lt;a href=&quot;https://github.com/d3/d3-force/&quot; target=&quot;_
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="尝试" scheme="http://geekplux.com/tags/%E5%B0%9D%E8%AF%95/"/>
    
      <category term="Web" scheme="http://geekplux.com/tags/Web/"/>
    
      <category term="WebGL" scheme="http://geekplux.com/tags/WebGL/"/>
    
      <category term="d3" scheme="http://geekplux.com/tags/d3/"/>
    
      <category term="three.js" scheme="http://geekplux.com/tags/three-js/"/>
    
      <category term="pixi.js" scheme="http://geekplux.com/tags/pixi-js/"/>
    
      <category term="Google Summer of Code" scheme="http://geekplux.com/tags/Google-Summer-of-Code/"/>
    
  </entry>
  
  <entry>
    <title>文本数据可视化（下）——一图胜千言</title>
    <link href="http://geekplux.com/2017/06/26/text-data-visualization.html"/>
    <id>http://geekplux.com/2017/06/26/text-data-visualization.html</id>
    <published>2017-06-26T05:57:41.000Z</published>
    <updated>2017-07-09T10:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于：<a href="https://zhuanlan.zhihu.com/p/27449788" target="_blank" rel="external">GraphiCon 知乎专栏-文本数据可视化（下）——一图胜千言</a></p>
</blockquote>
<p>文字是传递信息最常用的载体。在当前这个信息爆炸的时代，人们接收信息的速度已经小于信息产生的速度，尤其是文本信息。当大段大段的文字摆在面前，已经很少有耐心去认真把它读完，经常是先找文中的图片来看。这一方面说明人们对图形的接受程度比枯燥的文字要高很多，另一方面说明人们急需一种更高效的信息接收方式，文本可视化正是解药良方。「一图胜千言」我们从小就有体会，教材里的解释图、自己笔记里总结的知识结构图，一直到现在经常用的思维导图等，其实都是简单、实用的文本可视化。本文将简单介绍文本可视化的基础概念，然后重点通过各类文本可视化的案例来阐述可视化之美（多图，不过为了学到知识这点流量不算什么）。</p>
<h2 id="为什么要文本数据可视化"><a href="#为什么要文本数据可视化" class="headerlink" title="为什么要文本数据可视化"></a>为什么要文本数据可视化</h2><p>虽然一般这种讲必要性的段落很多人都略过不看，虽然文本可视化的必要性大家用脚趾头估计都能想到，但我还是稍微说一说吧。文本可视化的作用有以下四点：</p>
<ol>
<li><strong>理解</strong> - 理解主旨</li>
<li><strong>组织</strong> - 组织、分类信息</li>
<li><strong>比较</strong> - 对比文档信息</li>
<li><strong>关联</strong> - 关联文本的 pattern 和其他信息</li>
</ol>
<p>简单来说就是让你更加直观迅速的获取、分析信息（所有可视化的作用都是这个）。举个例子，针对一篇文章，文本可视化能更快的告诉我们文章在讲什么；针对社交网络上的发言，文本可视化可以帮我们信息归类，情感分析；针对一个大新闻，文本可视化可以帮我们捋顺事情发展的脉络、每个人物的关系等等；针对一系列的文档，我们可以通过文本可视化来找到它们之间的联系等等。</p>
<p>一般来说，情报分析人员、网络内容分析人员、情感分析或文学研究者等相关职业更需要文本可视化。不过随着信息图（例如图 1）等的普及，越来越多的人已经接受并善用文本可视化了。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5932f80b2d468.jpg" alt="图 1：一幅叫你怎么做信息图的信息图"></p>
<h2 id="文本数据可视化的流程"><a href="#文本数据可视化的流程" class="headerlink" title="文本数据可视化的流程"></a>文本数据可视化的流程</h2><p>如图 2 所示，其实任何可视化的流程<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">[1]</a>都类似。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5932f85a02711.png" alt="图 2：文本可视化流程"></p>
<p>一般把对文本的理解需求分成三级：词汇级（Lexical Level）、语法级（Syntactic Level）和语义级（Semantic Level）。不同级的信息挖掘方法也不同，词汇级当然是用各类分词算法，语法级用一些句法分析算法，语义级用主题抽取算法<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">[2]</a>。以上这些都在第二步文本信息挖掘中进行，其中文本数据预处理是将无效数据过滤，提取有效词等；文本特征抽取是指提取文本的关键词、词频分布、语法级的实体信息、语义级的主题等；文本特征的度量是指在多种环境或多个数据源所抽取的文本特征进行深层分析，如相似性、文本聚类等。这里就简单笼统地说一下文本分析的基础方法，有兴趣的同学可以自行搜索学习，我们把重点放在可视化设计上。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933efa249cfe.png" alt="Wordcount[3] 统计了通常用的86800个单词"></p>
<h2 id="文本可视化类型"><a href="#文本可视化类型" class="headerlink" title="文本可视化类型"></a>文本可视化类型</h2><p>文本数据大致可分为三种：单文本、文档集合和时序文本数据。对应的文本可视化也可分为三类：</p>
<ul>
<li>文本内容的可视化</li>
<li>文本关系的可视化</li>
<li>文本多层面信息的可视化</li>
</ul>
<p>以下我们通过案例来一一介绍。</p>
<h2 id="文本内容可视化"><a href="#文本内容可视化" class="headerlink" title="文本内容可视化"></a>文本内容可视化</h2><p>上篇文章所说的标签云和 Wordle <a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">[4]</a>是目前研究领域和 Web 上最受欢迎的文本内容可视化方法了，它们都是基于关键词的文本内容可视化。</p>
<h4 id="基于关键词的文本内容可视化"><a href="#基于关键词的文本内容可视化" class="headerlink" title="基于关键词的文本内容可视化"></a>基于关键词的文本内容可视化</h4><h5 id="DocuBurst"><a href="#DocuBurst" class="headerlink" title="DocuBurst"></a>DocuBurst</h5><p>文档散（DocuBurst [5]）也是基于关键词的文本可视化，不过它还通过径向布局体现了词的语义等级。如下图所示，外层的词是内层词的下义祠，颜色饱和度的深浅用来体现词频的高低。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031fe74aa3.png" alt=""></p>
<h5 id="Document-Cards"><a href="#Document-Cards" class="headerlink" title="Document Cards"></a>Document Cards</h5><p>文档卡片（Document Cards）[6]则是结合了文档中的关键词和关键图片进行可视化，布局在一张小卡片中。其中的关键图片是指采用智能算法抽取并根据颜色分类后的代表性图片。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933f0f44cf19.png" alt=""></p>
<h4 id="时序文本内容可视化"><a href="#时序文本内容可视化" class="headerlink" title="时序文本内容可视化"></a>时序文本内容可视化</h4><p>时序数据是指具有时间或顺序特性的文本，例如一篇小说故事情节的变化，或一个新闻事件随时间的演化。</p>
<h5 id="SparkClouds"><a href="#SparkClouds" class="headerlink" title="SparkClouds"></a>SparkClouds</h5><p>SparkClouds[7]是在标签云的基础上，在每个词下面增加了一条折线图，用以显示该词的词频随时间的演变。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933fed566376.png" alt="SparkCloud"></p>
<h5 id="ThemeRiver"><a href="#ThemeRiver" class="headerlink" title="ThemeRiver"></a>ThemeRiver</h5><p>主题河流（ThemeRiver）[8]是一种经典的时序文本可视化方法。光阴似水，用河流来隐喻时间的变化几乎所有人都能非常好地理解。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/5933f323e5d43.png" alt="ThemeRiver"></p>
<p>横轴表示时间，每一条不同颜色线条可视作一条河流，而每条河流则表示一个主题，河流的宽度代表其在当前时间点上的一个度量（如主题的强度）。这样既可以在宏观上看出多个主题的发展变化，又能看出在特定时间点上主题的分布。</p>
<h5 id="TIARA"><a href="#TIARA" class="headerlink" title="TIARA"></a>TIARA</h5><p>TIARA[9]结合了标签云，通过主题分析技术（latent dirichlet allocation，LDA），将文本关键词根据时间点放置在每条色带上，并用词的大小来表示关键词在该时刻出现的频率。因此用TIARA就可以帮助用户快速分析文本具体内容随时间变化的规律，而不是仅仅一个度量带变化。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/04/593409c1dbde1.png" alt="TIARA"></p>
<h5 id="TextFlow"><a href="#TextFlow" class="headerlink" title="TextFlow"></a>TextFlow</h5><p>TextFlow [10]也算是 ThemeRiver 的一种拓展，它不仅表达了主题的变化，还表达了各个主题随着时间的分裂与合并。如某个主题在某个时间分成了两个主题，或多个主题在某个时间合并成了一个主题。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad2d6548.png" alt="TextFlow"></p>
<h5 id="HistoryFlow"><a href="#HistoryFlow" class="headerlink" title="HistoryFlow"></a>HistoryFlow</h5><p>HistoryFlow [11]则主要研究文档内容随时间的变化。下图以维基百科一篇词条的更新为例，纵轴表示文章的版本更新时间点，每一种颜色代表一个作者，在同一个时间轴上色块代表相应的作者所贡献的文字块，并且色块的位置代表该文字块在文章中的顺序。所以纵览全图就可以轻易看出文章的修改。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad31e48b.png" alt="HistoryFlow"></p>
<h5 id="StoryFlow"><a href="#StoryFlow" class="headerlink" title="StoryFlow"></a>StoryFlow</h5><p>我们看电影或小说经常说到时间线、剧情线等，都能用 StoryFlow [12]来表示，它通过层次渲染的方式，生成一个 StoryLine 布局。每条线是一条人物线，当两人在剧情中有某种联系（同时出场或其他交集）时会在图中相交，横轴表示时间。</p>
<p>StoryFlow 还允许用户实时交互，包括捆绑操作、删除、移动以及直线化等等。视频演示非常精彩，需科学上网：<a href="https://www.youtube.com/watch?v=yoq82mC30Iw" target="_blank" rel="external">https://www.youtube.com/watch?v=yoq82mC30Iw</a></p>
<p><img src="https://ooo.0o0.ooo/2017/06/14/59412ad2c4740.png" alt="StoryFlow"></p>
<h4 id="文本特征分布模式可视化"><a href="#文本特征分布模式可视化" class="headerlink" title="文本特征分布模式可视化"></a>文本特征分布模式可视化</h4><p>可视化也能很好的表现文本特征。</p>
<h5 id="TextArc"><a href="#TextArc" class="headerlink" title="TextArc"></a>TextArc</h5><p>TextArc [13]用来可视化一个文档中的词频和词的分布情况。整个文档用一条螺线表示，文档的句子按文字的组织顺序布局在螺线上，螺线包围着的是文档中出现的单词，每个单词的位置由其在文本中的频率和出现位置决定，饱和度用来映射词频。所以全局出现频率越高的词越靠近中心，而局部出现频率越高的词越靠近其相应的螺线区域。选中某个单词后，自动用射线关联到它在文中出现的位置。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e89856682.png" alt="Textarc"></p>
<h5 id="Literature-Fingerprinting"><a href="#Literature-Fingerprinting" class="headerlink" title="Literature Fingerprinting"></a>Literature Fingerprinting</h5><p>文献指纹（Literature Fingerprinting）[14]是体现全文特征分布的一项工作。一个像素块代表一段文本，一组像素块代表一本书。颜色映射的是文本特征，下图中是句子的平均长度。从图中明显看出两人的写作风格迥异。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897d8434.png" alt="Literature Fingerprinting"></p>
<h4 id="情感分析可视化"><a href="#情感分析可视化" class="headerlink" title="情感分析可视化"></a>情感分析可视化</h4><p>情感分析是指从文本中挖掘出心情、喜好、感觉等主观信息。现在人们把各类社交网络当作感情、观点的出口，所以分析这类文本就能掌握人们对于一个事件的观点或情感的发展。下图是基于矩阵视图的客户反馈信息的可视化工作[15]，其中的行是指文本（用户观点）的载体，列是用户的评价，颜色表达的是用户评价的倾向程度，红色代表消极，蓝色代表积极，每个方格内的小格子代表用户评价的人数，评价人数越多小格子越大。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897ebec4.png" alt="情感分析"></p>
<h2 id="文本关系可视化"><a href="#文本关系可视化" class="headerlink" title="文本关系可视化"></a>文本关系可视化</h2><p>顾名思义，文本关系可视化研究的是文本或文档集合中的关系信息，比如文本的相似性、互相引用的情况、链接等。说到关系布局，一般都是树或图。</p>
<h4 id="文本内容关系可视化"><a href="#文本内容关系可视化" class="headerlink" title="文本内容关系可视化"></a>文本内容关系可视化</h4><h5 id="Word-Tree"><a href="#Word-Tree" class="headerlink" title="Word Tree"></a>Word Tree</h5><p>单词树（Word Tree）[16]很好理解，把文本中的句子按树形结构布局，可以很好的看出一个单词在文本中出现的频率和单词前后的联系。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e8980de0c.png" alt="Word Tree.png"></p>
<h5 id="Phrase-Nets"><a href="#Phrase-Nets" class="headerlink" title="Phrase Nets"></a>Phrase Nets</h5><p>短语网络（Phrase Nets）[17]是经典的力导向图结构，图中的节点是从文本中挖掘出的词汇级或语法级的语义单元，边代表语义单元的联系，边的方向即短语的方向，边的宽度是短语在文本中出现的频率。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e897b8220.png" alt="Phrase Nets.png"></p>
<h5 id="NewsMap"><a href="#NewsMap" class="headerlink" title="NewsMap"></a>NewsMap</h5><p>TreeMap 也是一种经典的可视化关系布局。NewsMap 就是基于 TreeMap 展示新闻，颜色用于区分新闻类型。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941e89847efb.png" alt="Newsmap.png"></p>
<h4 id="文档集合关系可视化"><a href="#文档集合关系可视化" class="headerlink" title="文档集合关系可视化"></a>文档集合关系可视化</h4><p>文档数量到一定量的时候，再针对文本做可视化就不现实了，所以通常是对单个文档定义一个特征向量，利用向量空间模型计算文档间的相似性，并采用相应的投影技术呈现文档集合的关系。</p>
<h5 id="Galaxy-View"><a href="#Galaxy-View" class="headerlink" title="Galaxy View"></a>Galaxy View</h5><p>星系图（Galaxy View）[18]把一篇文档比作一颗星星，通过投影的方法把所有文档按照其主题的相似性投影为二维平面的点集，星星离的越近则代表文档越相似，因此一个星团可以非常直观地看出文档主题的紧凑和离散。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f41b47937.png" alt="Galaxy View"></p>
<h5 id="ThemeScape"><a href="#ThemeScape" class="headerlink" title="ThemeScape"></a>ThemeScape</h5><p>主题地貌（ThemeScape）[18]是对星系图的改进。地图中的等高线我相信大家都理解，把等高线加入投影的二维平面中，文档相似性相同的放在一个等高线内，再用颜色来编码文本分布的密集程度，把二维平面背景变成一幅地图，这样就把刚才星系图中的星团变成了一座座山丘。文档越相似，则分布约密集，这座山峰就越高，是不是一目了然？</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f478ec87d.png" alt="ThemeScape"></p>
<h5 id="Jigsaw"><a href="#Jigsaw" class="headerlink" title="Jigsaw"></a>Jigsaw</h5><p>Jigsaw [19]通过提供多种视图让用户交互分析文档间的关系。最下面是文档视图，里面是单个文档的内容，最上面列表图中每一行是文档中的一个实体，连线代表实体间的关系。中间部分，左面是一副节点-链接图，白色节点表示一篇文档，其他节点是文档中的实体，链接同样代表联系；右面的散点图中，一个菱形代表两个实体的联系。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941f45268950.png" alt="Jigsaw"></p>
<h2 id="文本多层面信息可视化"><a href="#文本多层面信息可视化" class="headerlink" title="文本多层面信息可视化"></a>文本多层面信息可视化</h2><p>多层面或多维度是指从多个角度或提取多种特征对文本集合分析。</p>
<h5 id="FaceAtlas"><a href="#FaceAtlas" class="headerlink" title="FaceAtlas"></a>FaceAtlas</h5><p>FaceAtlas [20]结合了气泡集和节点-链接图两种视图，用于表达文本各层面信息内部和外部的关联。每个节点表示一个实体，用 KDE 方法刻画出气泡图的轮廓，然后用线将同一层面的实体链接起来，一种颜色代表一种实体。下图是基于医疗健康文档，展示了病名、病因、症状、诊断方案等多层面的信息，两团分别代表糖尿病1号和2号，连线是指他俩之间的并发症。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941fc7386d50.png" alt="faceatlas.png"></p>
<h5 id="Parallel-Tag-Clouds"><a href="#Parallel-Tag-Clouds" class="headerlink" title="Parallel Tag Clouds"></a>Parallel Tag Clouds</h5><p>平行标签云（Parallel Tag Clouds）[21]结合了平行坐标（该视图在多维数据可视化中经常使用）和标签云视图。每一列是一个层面的标签云，然后连接的折线展现了选中标签在多个层面的分布。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/15/5941fc7fd281e.png" alt="parallel_tag_clouds.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天带大家看了这么多图，相信大家一定眼花缭乱了。要理解文本数据可视化，就要先了解文本数据的特点，如何从文本中挖掘出你想要的信息，如何设计数据结构，最后再如何映射出实用又美观的视图都是你需要思考的问题。目前文本可视分析已经开始运用在各行各业，直观的交互将人类的智慧引入到数据分析的过程中，帮助我们从浩瀚的文字中跳脱出来，避免一叶障目。希望我的文章能给大家带来一些微小的帮助。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1] <a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">数据可视化基础——可视化流程</a></li>
<li>[2] <a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[3] <a href="http://www.wordcount.org/" target="_blank" rel="external">WordCount</a></li>
<li>[4] <a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">文本数据可视化（上）——从 Wordle 谈起</a></li>
<li>[5] Collins C, Carpendale S, Penn G. Docuburst: Visualizing document content using language structure[C]//Computer graphics forum. Blackwell Publishing Ltd, 2009, 28(3): 1039-1046.</li>
<li>[6] Strobelt H, Oelke D, Rohrdantz C, et al. Document cards: A top trumps visualization for documents[J]. IEEE Transactions on Visualization and Computer Graphics, 2009, 15(6): 1145-1152.</li>
<li>[7] Lee B, Riche N H, Karlson A K, et al. Sparkclouds: Visualizing trends in tag clouds[J]. IEEE transactions on visualization and computer graphics, 2010, 16(6): 1182-1189.</li>
<li>[8] Havre S, Hetzler E, Whitney P, et al. Themeriver: Visualizing thematic changes in large document collections[J]. IEEE transactions on visualization and computer graphics, 2002, 8(1): 9-20.</li>
<li>[9] Wei F, Liu S, Song Y, et al. Tiara: a visual exploratory text analytic system[C]//Proceedings of the 16th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2010: 153-162.</li>
<li>[10] Cui W, Liu S, Tan L, et al. Textflow: Towards better understanding of evolving topics in text[J]. IEEE transactions on visualization and computer graphics, 2011, 17(12): 2412-2421.</li>
<li>[11] Wattenberg M, Viégas F B. Historyflow: visualizing dynamic, evolving documents and the interactions of multiple collaborating authors, A preliminary report[J]. IBM Research, Collaborative User Experience research group, 2003.</li>
<li>[12] Liu S, Wu Y, Wei E, et al. Storyflow: Tracking the evolution of stories[J]. IEEE Transactions on Visualization and Computer Graphics, 2013, 19(12): 2436-2445.</li>
<li>[13] Paley W B. TextArc: Showing word frequency and distribution in text[C]//Poster presented at IEEE Symposium on Information Visualization. 2002, 2002.</li>
<li>[14] Keim D A, Oelke D. Literature fingerprinting: A new method for visual literary analysis[C]//Visual Analytics Science and Technology, 2007. VAST 2007. IEEE Symposium on. IEEE, 2007: 115-122.</li>
<li>[15] Oelke D, Hao M, Rohrdantz C, et al. Visual opinion analysis of customer feedback data[C]//Visual Analytics Science and Technology, 2009. VAST 2009. IEEE Symposium on. IEEE, 2009: 187-194.</li>
<li>[16] Wattenberg M, Viégas F B. The word tree, an interactive visual concordance[J]. IEEE transactions on visualization and computer graphics, 2008, 14(6).</li>
<li>[17] Van Ham F, Wattenberg M, Viégas F B. Mapping text with phrase nets[J]. IEEE transactions on visualization and computer graphics, 2009, 15(6).</li>
<li>[18] Wise J A. The ecological approach to text visualization[J]. Journal of the Association for Information Science and Technology, 1999, 50(13): 1224.</li>
<li>[19] Stasko J, Görg C, Liu Z. Jigsaw: supporting investigative analysis through interactive visualization[J]. Information visualization, 2008, 7(2): 118-132.</li>
<li>[20] Cao N, Sun J, Lin Y R, et al. Facetatlas: Multifaceted visualization for rich text corpora[J]. IEEE transactions on visualization and computer graphics, 2010, 16(6): 1172-1181.</li>
<li>[21] Collins C, Viegas F B, Wattenberg M. Parallel tag clouds to explore and analyze faceted text corpora[C]//Visual Analytics Science and Technology, 2009. VAST 2009. IEEE Symposium on. IEEE, 2009: 91-98.</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27449788&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphiCon 知乎专栏-文本数据可视化（下）——一图胜千言&lt;/a&gt;&lt;/p
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>文本数据可视化（上）——从 Wordle 谈起</title>
    <link href="http://geekplux.com/2017/04/12/text-data-visualization-wordle.html"/>
    <id>http://geekplux.com/2017/04/12/text-data-visualization-wordle.html</id>
    <published>2017-04-12T02:44:01.000Z</published>
    <updated>2017-04-14T03:06:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文首发于：<a href="https://zhuanlan.zhihu.com/p/26306683" target="_blank" rel="external">GraphiCon 知乎专栏-文本数据可视化（上）——从 Wordle 谈起</a></p>
</blockquote>
<p>看到题目，你可能一脸懵逼，什么是 wordle？下面这幅图就是：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f0320078efe.png" alt=""></p>
<p>是不是很熟悉？大到宣传海报，小到个人名片，Wordle 如今随处可见。它可以轻松的展示出一段文字的关键词，让我们对这段话的内容一目了然。其实这属于数据可视化中的文本内容可视化，常用于社交网络中的内容分析，<em>还记得前几年微博有有个插件（现在似乎找不到了），用户可以一键生成自己的微博关键词，当时引起了大量转发，因为很多用户的关键词出乎意料，让自己都大吃一惊</em>。本文就从最简单的 Wordle 说起，说说文本内容可视化，以窥数据可视化一隅。</p>
<h2 id="为什么要有-Wordle？"><a href="#为什么要有-Wordle？" class="headerlink" title="为什么要有 Wordle？"></a>为什么要有 Wordle？</h2><p>其实要回答这个问题就要回答为什么要做数据可视化。我们先看下面这段话：</p>
<blockquote>
<p>GraphiCon取GraphicsCon图形控之意（类比lolicon）。<br>我们会把我们觉得有趣的，好玩的，有用的图形学相关的技术，知识，想法，资讯放到GraphiCon这个小空间里。<br>GraphiCon的po主们虽然遍布天涯海角，在从事着不同的事，但都是痴迷计算机图形学的小伙伴们。<br>只要你也对计算机图形学感兴趣，或者喜欢好玩有趣狂拽酷炫的图形项目，那么你也是GraphiCon！</p>
</blockquote>
<p>一眼扫过去，你可能能轻松地注意到 <strong>GraphiCon</strong> 出现了 4 次。而还有个关键词「<strong>图形</strong>」，虽然出现了 5 次，但显然没有 GraphiCon 醒目。平时阅读比较快的同学可能有一目十行的本领，其本质就是关键词提取。瞬间了解一段话的大意，进而判断要不要花时间去读。但这完全取决于你个人提取关键字的能力。如果换一种图形的形式，可能就会非常直观：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/04/58e35ca7a99a0.png" alt=""></p>
<p>看这张图明显比看枯燥的文字要直观的多，而且<strong>还意外发现了「计算机图形学」这个词的频率竟然也挺高</strong>。它在原文中出现了两次，这是我们单纯看文字很难发现的。不过，这幅图还不是最好的效果，你可能也发现：除了词频高的词，其他关键词很小，根本看不清；而且整个布局很零散，空白太多，没有一种聚合的感觉。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f9367fa.png" alt=""></p>
<p>这幅比上面的又稍美观了一点，同时对词的重要性也进行了重新统计，不再是单纯的根据词频。可能你觉得还不够美，那这样：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f49a275.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/14/58f031f5ad7e5.png" alt=""><br><img src="https://ooo.0o0.ooo/2017/04/14/58f031f75d220.png" alt=""></p>
<p>哈哈，还有很多好玩的，不过例子中这段话的篇幅太短，关键词太少，所以显得不是很紧凑，很多更酷炫的样式也不适用了。</p>
<p>至此，我们可以总结一下 Wordle 的作用：</p>
<ul>
<li>把枯燥的数据直观地呈现出来，使人更好的洞察数据</li>
<li>更有利于数据分析（比如发现「图形」才是出现最多的词）</li>
</ul>
<p>其实数据可视化就是把复杂的数据转化为直观的图形，方便人们洞悉。而且刚才这个例子还只是最简单的文本数据，如果是非常复杂的数据，普通人根本看不懂的那种，就更需要数据可视化为我们抽丝剥茧，完美呈现。关于可视化的必要性我会慢慢渗透到之后的每一篇文章中，接下来开始介绍 Wordle 的制作过程。</p>
<h2 id="文本信息的提取"><a href="#文本信息的提取" class="headerlink" title="文本信息的提取"></a>文本信息的提取</h2><p>任何的数据可视化都离不开三大步骤[1]：分析、处理、生成，Wordle 亦然[2]。如何从一段文字变成一张优美的图片，我们大概要经历以下步骤：</p>
<ul>
<li>提取关键词（去掉冗余的文字）</li>
<li>计算关键词权重（决定哪些词着重显示）</li>
<li>布局（算出每个词摆放的位置）</li>
</ul>
<p>第一步中，英文的分词相对中文来说简单的多（在创作本文的过程中，我几乎是找遍了中文标签云制作工具，没发现一款分词做的好的），把单词都分开后，去掉一些助词如 the、a、that 等，再把单词的时态语态还原就好了。第二步最常用的就是计算词频了，一个词出现的次数越多它的权重越大（Wordle 就是用了词频）。除此之外，还有用单词在句子中的成分来判断其重要性的、有用各种概率模型的，这涉及到自然语言处理和文本信息挖掘，总之方法多种多样。另外，文本数据挖掘一直也是热门的研究话题，尤其是中文处理这道难以逾越的鸿沟。大家有兴趣可以自行研究。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>把单词任意排列的表现形式，最早的灵感来自于排版印刷：</p>
<p><img src="http://i587.photobucket.com/albums/ss314/zhangdiwaa/my%20blog%20photo/QQ56FE724720140201125127.jpg" alt=""></p>
<p>上图是《数据可视化之美》的配图，分别来自美国国家设计研究中心和古埃及草纸。95 年在动漫作品 EVA 中，词云的表现形式也有所体现[4]。</p>
<p><img src="http://i587.photobucket.com/albums/ss314/zhangdiwaa/my%20blog%20photo/20090621150654-1533987883.jpg" alt=""></p>
<p>这种看似杂乱无章的排布，恰恰与人类的跳跃思维相契合，人脑的思绪随着视觉的跳动也跟着不断联想。</p>
<p>而在计算机上，最早的文字可视化其实是「标签云」。当年博客爆发的时代，几乎每个博客里都有一个这样的插件：</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031f6bce01.png" alt=""></p>
<p>它用文字的大小和颜色的深浅来表达了文字在文本中的重要性，比你单纯看一段文字要直观的多。但它的缺点也很多：从美的角度来说，它同一行如果有一个词字体特别大则直接导致行距变大，不仅造成了空间的浪费，还让整体看起来非常不整齐、不协调；从信息展现的角度来说，字体的深浅大小不能更好的体现差异，比如上图中 good 的权重是 50，而 life 的权重是 20，但它俩看起来的差别并不大。</p>
<p>后来出现的 Wordle 针对这些缺点一一作了改进。首先它用字体的粗度来加深权重的展示，因为人的视觉对面积的感知比对饱和度的感知要强，所以加粗字体效果拔群；其次 Wordle 用紧凑的布局给人以美的享受，你甚至可以给定形状来生成不同的 Wordle。</p>
<p><img src="https://ooo.0o0.ooo/2017/03/19/58cd69ce5724c.jpg" alt=""></p>
<p>Wordle 具体采用的算法是贪婪算法，最开始在给定区域内把最重要的单词先摆到某个位置（这个位置你可以指定，一般是中心线），然后用下个单词在它的旁边不停做交叠测试，直到没有重叠。依次迭代，直到每个单词都摆放好。</p>
<h3 id="Wordle-有什么不足之处"><a href="#Wordle-有什么不足之处" class="headerlink" title="Wordle 有什么不足之处"></a>Wordle 有什么不足之处</h3><p>虽然 Wordle 的设计已经很美观，但作为一个有批判性思维的少年，我们还是要对它批判一番：</p>
<ul>
<li>Wordle 美观程度很大程度依赖于它所选的字体。相信你也见过宋体中文的 Wordle。。</li>
<li>相同权重的单词，可能越长的显得权重越大，因为它占得面积更大。</li>
<li>颜色意义不大。不过现在这个好像变成了优势，使它可以与不同图片结合。</li>
</ul>
<h2 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h2><p>Wordle 算是文本内容可视化中最经典的形式，除此之外还有一些更有趣的，比如下图的 DocuBurst [4]。它用环形布局巧妙地展示了文本的层级关系，外圈的单词是内圈单词的下一层。</p>
<p><img src="https://ooo.0o0.ooo/2017/04/14/58f031fe74aa3.png" alt=""></p>
<p>正所谓“一图胜千言”，文本可视化把枯燥的文字变成有趣的图片帮助人们加深理解，可以说是功不可没。如果有兴趣继续了解可视化相关的内容，敬请期待下一期。</p>
<ul>
<li><a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">[1] 数据可视化基础——可视化流程</a></li>
<li><a href="http://www.wordle.net/" target="_blank" rel="external">[2] Wordle.net</a></li>
<li><a href="https://book.douban.com/subject/6439420/" target="_blank" rel="external">[3] 数据可视化之美</a></li>
<li><a href="http://www.storagelab.org.cn/zhangdi/2014/02/07/wordle/" target="_blank" rel="external">[4] wordle和单词云的起源、原理与制作</a></li>
<li><a href="http://vialab.science.uoit.ca/wp-content/papercite-data/pdf/col2009a.pdf" target="_blank" rel="external">[5] DocuBurst: Visualizing Document Content using Language Structure</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文首发于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/26306683&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GraphiCon 知乎专栏-文本数据可视化（上）——从 Wordle 谈起&lt;
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>我获取信息的渠道</title>
    <link href="http://geekplux.com/2017/01/14/the-ways-to-get-information.html"/>
    <id>http://geekplux.com/2017/01/14/the-ways-to-get-information.html</id>
    <published>2017-01-13T16:10:52.000Z</published>
    <updated>2017-02-22T16:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>互联网迅猛的浪潮抹平了信息的鸿沟，却也让优质的信息变得如沧海一粟。人们常言「信息不对等」，往往在感慨<strong>有价值的信息</strong>总是被人捷足先登。正因这些信息如此重要，催生了一代又一代、各式各样的信息获取工具。</p>
<h2 id="我阅读工具的演化史"><a href="#我阅读工具的演化史" class="headerlink" title="我阅读工具的演化史"></a>我阅读工具的演化史</h2><p>印象中，最早的信息聚合网站，应该是叫「<a href="https://en.wikipedia.org/wiki/Golden_Pages" target="_blank" rel="external">黄页</a>」，已经有 100 多年的历史，马云早期的创业项目就叫「中国黄页」。后来家里的 IE 首页变成了一些门户网站，这时候获取信息主要靠手动点击链接到各大网站。再之后，我接触到了 <strong>Google Reader</strong>，认识了 RSS，从此开启了一扇新的大门。</p>
<p>之前获取信息的方式是自己主动探索，而现在只需要维护好自己的 RSS 订阅列表，就会有感兴趣的信息源源不断地流进来。犹记得当时我的订阅列表很长，每天点开都是几百上千的未读，<strong>快速扫一遍，把感兴趣的随手添加到 pocket（因为 pocket 可以离线阅读），抽碎片时间打开 pocket 阅读，遇到好文章再收藏到 Evernote</strong>，这个阅读流一直沿用了一两年。即使后来 Google Reader 被 Google 遗弃我也坚持用 RSS，只是频率比以前低了不少。</p>
<p>再到后来，不少博客写手开始转战到了微信公众号，很多文章用微信直接阅读，体验也挺好，于是阅读公众号成了我当时新的阅读方式。然而好景不长，很快公众平台就被一堆营销号攻占，一些写手为了圈钱，写作质量也大幅下降。我开始慢慢取关公众号，并且意识到了一个问题：<strong>大多数的文章都是没有价值的，或者说远没有自己想象的有价值</strong>。很多文章都是东拼西凑来的，能引发思考的凤毛麟角。</p>
<p>别人的文章好似二手的知识，我们如果想获取一手的就要追根溯源，看他参考的文献、引用的书籍，与其这样，为什么不直接看书或看论文？想通这点之后，我就把阅读的绝大部分时间放在了看书上，看文章的时间可能一天只有不到半小时。</p>
<h2 id="我现阶段的信息获取方式"><a href="#我现阶段的信息获取方式" class="headerlink" title="我现阶段的信息获取方式"></a>我现阶段的信息获取方式</h2><p>我现在的信息渠道主要分四部分：</p>
<ul>
<li>书籍、论文（不在本文讨论范围内，阅读论文可参考<a href="http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html">《如何阅读一篇学术论文》</a></li>
<li>邮件列表</li>
<li>RSS</li>
<li>经常去逛的一些网站</li>
</ul>
<h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>RSS 列表主要分两部分，一部分是个人博客，另一部分是少数几个信息聚合类网站和一些期刊、杂志。其中重点看个人博客，由于现在大家的博客更新都很慢，所以一般我一周没看也攒不了几篇。期刊杂志我也会留心，因为有一些和我研究方向——数据可视化有关的。</p>
<p>现在我的 RSS 软件主要用 <a href="http://www.inoreader.com/" target="_blank" rel="external">inoreader</a>，基本功能都有，也提供了夜间模式（对于夜猫子来说很重要），感觉还不错。</p>
<h4 id="Mailing-List"><a href="#Mailing-List" class="headerlink" title="Mailing List"></a>Mailing List</h4><p>邮件列表也算是一种很古老的信息获取方式。我主要用它来做两件事：订阅一些 Google Group 来划划水；订阅一些日报和周报。</p>
<p>之所以选择邮件列表看周报，主要是基于以下两个原因：</p>
<ul>
<li>本质上日报或周报已经是别人筛选过一遍的文章，所以质量相对一些信息聚合网站也会高一点</li>
<li>日报或周报降低了阅读的频次</li>
</ul>
<p>日报一天一封，周报一周才一封，保证了你一周只会看这封邮件一次，这大大地节约了浪费在无效信息上的时间。很多网站还提供日报和周报的切换功能，非常方便。</p>
<p>我这里列一些我订阅的，期待大家能在文末评论（或发邮件给我），互通有无。</p>
<ul>
<li><a href="http://weekly.codetengu.com/" target="_blank" rel="external">CodeTengu Weekly 碼天狗週刊</a></li>
<li><a href="http://memect.com/" target="_blank" rel="external">好东西传送门</a> 的机器学习日报、大数据日报、Python、Web 日报</li>
<li><a href="http://www.wildml.com/" target="_blank" rel="external">The Wild Week in AI</a></li>
<li>This week’s hi-res photos from Unsplash</li>
<li><a href="http://javascriptweekly.com/" target="_blank" rel="external">JavaScript Weekly</a></li>
<li><a href="http://frontendfocus.co/" target="_blank" rel="external">FrontEnd Focus</a></li>
<li><a href="https://blog.risingstack.com/" target="_blank" rel="external">RisingStack Engineering</a></li>
<li><a href="http://css-weekly.com/" target="_blank" rel="external">CSS Weekly</a></li>
<li><a href="http://webtoolsweekly.com/" target="_blank" rel="external">Web Tools Weekly</a></li>
<li><a href="http://www.gitxiv.com/" target="_blank" rel="external">GitXiv Top Posts</a></li>
<li><a href="http://rubyweekly.com/" target="_blank" rel="external">Ruby Weekly</a></li>
<li><a href="http://nodeweekly.com/" target="_blank" rel="external">Node Weekly</a></li>
<li><a href="http://dataelixir.com/" target="_blank" rel="external">Data Elixir</a></li>
<li><a href="https://web-design-weekly.com/" target="_blank" rel="external">Web Design Weekly</a></li>
<li>Product Hunt Daily Digest</li>
<li>Quora Digest</li>
<li>Medium Daily Digest</li>
</ul>
<h4 id="经常去逛的"><a href="#经常去逛的" class="headerlink" title="经常去逛的"></a>经常去逛的</h4><p>人不能两耳不闻窗外事，总得适当的划水。我经常去逛的网站有</p>
<ul>
<li><a href="https://news.ycombinator.com/" target="_blank" rel="external">Hacker News</a></li>
<li><a href="https://www.reddit.com/" target="_blank" rel="external">reddit</a> - <a href="https://www.reddit.com/r/programming" target="_blank" rel="external">programming</a> 质量不错</li>
<li><a href="https://github.com/explore" target="_blank" rel="external">GitHub Explore</a> - 当然我邮件里也订阅了这个</li>
<li><a href="https://www.v2ex.com/" target="_blank" rel="external">v2ex</a> - v 站虽然划水时间占 99%，但小道消息还挺多的</li>
<li><a href="http://www.bilibili.com/" target="_blank" rel="external">bilibili</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>任何事都是先做加法，再做减法的过程。我的 RSS 列表和邮件列表都曾经短期内迅速变长，后来又被我精心筛选到寥寥无几，不过我现在还是觉得有点多。</p>
<p>我用的工具可能都比较复古，但是经久不衰的东西才真正不会被淘汰。尤其是邮件，这个几乎是网络一出现就有的东西，现在、未来都会依旧重要。</p>
<p>最后还有个小技巧：文章是否值得读，不取决于题目是否夺人眼球，可能取决于你多个信息渠道中它重复出现的次数。</p>
<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>既然本文是信息获取的渠道，那就不应该局限于阅读方面。除了阅读以为，Podcast 也是我特别喜爱的信息获取方式。我目前一共订阅了 54 个 Podcast，其中大部分是和科技相关，IPN 系列之前搞的很专业，但是现在不太行了。《锵锵三人行》是我逢人推荐的，从小听到大。听 Podcast 可以主观上缩短你的通勤时间，虽然没有阅读那么效率，但作为陶冶情操、增广见闻的手段还是可以的。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;互联网迅猛的浪潮抹平了信息的鸿沟，却也让优质的信息变得如沧海一粟。人们常言「信息不对等」，往往在感慨&lt;strong&gt;有价值的信息&lt;/strong&gt;总是被人捷足先登。正因这些信息如此重要，催生了一代又一代、各式各样的信息获取工具。&lt;/p&gt;
&lt;h2 id=&quot;我阅读工具的演化史&quot;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
      <category term="Read" scheme="http://geekplux.com/tags/Read/"/>
    
      <category term="阅读" scheme="http://geekplux.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——视觉编码</title>
    <link href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html"/>
    <id>http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html</id>
    <published>2017-01-03T12:02:52.000Z</published>
    <updated>2017-01-10T05:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第三篇，主要介绍<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>和<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>，建议从可视化流程看起。<br>原文地址：<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html</a></p>
</blockquote>
<p>终于来到了最后一篇，前两篇的铺垫可能有点长，但是不种苗浇水怎能开枝散叶。可视化编码是可视化中的<strong>核心内容</strong>，本文会对其进行详细的讲解，尤其是<strong>视觉编码</strong>与<strong>视觉通道</strong>两个概念，如果其中遇到晦涩之处，不要心急，可囫囵吞枣直接往下看。</p>
<h2 id="什么是视觉编码（visual-encoding）"><a href="#什么是视觉编码（visual-encoding）" class="headerlink" title="什么是视觉编码（visual encoding）"></a>什么是视觉编码（visual encoding）</h2><p>很多人可能看到题目的时候就有这个疑问，到底什么是视觉编码。其实视觉编码很简单，用一句话就能概括：</p>
<blockquote>
<p>视觉编码描述的是将数据映射到最终可视化结果上的过程。</p>
</blockquote>
<p>这里的可视化结果可能是图片，也可能是一张网页等等。</p>
<p>编码二字，如果说<strong>编</strong>是指设计、映射的过程，那么码呢？<strong>码</strong>其实指的是一些图形符号。</p>
<h2 id="图形能告诉我们什么"><a href="#图形能告诉我们什么" class="headerlink" title="图形能告诉我们什么"></a>图形能告诉我们什么</h2><p>在介绍各类图形符号之前，我们先谈谈：图形能告诉我们什么。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/pic.png" alt=""></p>
<p>仔细观察上方这个简单的图片，你能得得到什么信息？</p>
<ol>
<li>A B C 是不同的</li>
<li>B 在 A 和 C 的中间</li>
<li>BC 的长度是 AB 的大概两倍</li>
</ol>
<p>得益于我们视觉系统的强大，这些信息不假思索就能得出。如果把上图想象成一个二维坐标系，则我们可能得出更多的结论。</p>
<blockquote>
<p>“Resemblance, order and proportion are the three signfields in graphics.” - Bertin [1]</p>
</blockquote>
<p>图形符号和信息间的映射关系使我们能迅速获取信息。所以我们可以把图片看成一组图形符号的组合，这些图形符号中<strong>携带</strong>了一些信息，我们称作它<strong>编码</strong>了一些信息。而当人们从这些符号中<strong>读取</strong>信息时，我们称作我们<strong>解码</strong>了一些信息。</p>
<p>我们人类解码信息靠的是我们的眼睛、我们的视觉系统。如果说图形符号是编码信息的工具或通道、那么我们的视觉就是解码信息的通道。因此，我们通常把这种<strong>图形符号&lt;——&gt;信息&lt;——&gt;视觉系统</strong>的对应称作<strong>视觉通道</strong>。</p>
<p>至此算是把<strong>视觉通道</strong>、<strong>视觉编码</strong>这两个概念讲清楚了。如果一个人说他想用四个通道来编码四个维度的数据，即可以翻译成他想用四种图形符号来对应这份数据表的四个列的信息。</p>
<p>这里举个例子（例子来自于 [2]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a>）：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/example.png" alt="例子来自于陈为 沈则潜 陶煜波《数据可视化》"></p>
<ul>
<li>上图中图 A 表示了三个不同班级的数学平均分，用柱状图表示，柱状图的<strong>高度</strong>作为一个视觉通道，编码了数学平均分的<em>值</em>；柱状，这个<strong>形状</strong>作为一个视觉通道编码了数学平均分这一<em>属性</em>。</li>
<li>图 B 中，我们想在 A 的基础上多展示语文平均分这一项数据（即增加了一个数据维度），则选用点这个<strong>形状</strong>通道编码这两个<em>属性</em>；点的<strong>横坐标</strong>编码语文平均分的<em>值</em>；点的<strong>纵坐标</strong>编码数学平均分的<em>值</em>。</li>
<li>这时候发现图 B 中我们把班级这个数据维度给丢掉了，于是我们可以用<strong>颜色</strong>这一视觉通道来编码班级这个<strong>属性</strong>信息，如图 C。</li>
<li>如果我们还想展示班级<em>人数</em>这一信息，则可以用<strong>尺寸</strong>这一视觉通道来编码，如图 D。</li>
</ul>
<h2 id="视觉编码中常用的视觉通道"><a href="#视觉编码中常用的视觉通道" class="headerlink" title="视觉编码中常用的视觉通道"></a>视觉编码中常用的视觉通道</h2><p>1967 年，Jacques Bertin 初版的《Semiology of Graphics》一书提出了图形符号与信息的对应关系（就是本文上一节的内容），奠定了可视化编码的理论基础。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/signal.png" alt="Bertin J. Semiology of graphics: diagrams[C]// Conference on Computer Networks. 1983."></p>
<p>如上图所示，书中把图形符号分为两种：</p>
<ul>
<li><strong>位置变量</strong>：一般指二维坐标</li>
<li><strong>视网膜变量</strong>：<strong>尺寸</strong>、<strong>数值</strong>、<strong>纹理</strong>、<strong>颜色</strong>、<strong>方向</strong>和<strong>形状</strong></li>
</ul>
<p>以上基本的图形符号共有 7 种。将其映射到点、线、面之后，就相当于有 21 种编码可用的视觉通道。后来人们还又补充了几种其他的视觉通道：<strong>长度</strong>、<strong>面积</strong>、<strong>体积</strong>、<strong>透明度</strong>、<strong>模糊/聚焦</strong>、<strong>动画</strong>等，所以可用的视觉通道其实太多了。</p>
<p>而一般一份可视化作品可用到的视觉通道要尽可能得少，因为太多了反而会造成我们视觉系统的混乱，使我们获取信息更难。于是这就涉及到了视觉通道的设计原则。</p>
<h2 id="视觉编码设计原则"><a href="#视觉编码设计原则" class="headerlink" title="视觉编码设计原则"></a>视觉编码设计原则</h2><p>这一节其实可以单独再分一篇文章写，因为可视化编码设计实在是复杂：假设我们有 k 个视觉通道，有 n 个数据维度，则一共有 <code>(n+1)^k</code> 种编码方案……从中选出一种最佳方案难度可见一斑。</p>
<p>不过既然本文是讲解视觉编码相关，所以这个章节是逃不掉的，在此提纲挈领讲一下。如果想深入了解，可以阅读参考文献中提到的书籍。</p>
<h3 id="视觉通道的三个性质"><a href="#视觉通道的三个性质" class="headerlink" title="视觉通道的三个性质"></a>视觉通道的三个性质</h3><p>上一篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>讲解了可视化中数据分为三类：<strong>类别型</strong>、<strong>有序型</strong>、<strong>数值型</strong>。</p>
<ol>
<li><strong>定性性质</strong>（或叫分类性质）。适用于类别型数据。比如形状或颜色，这两个视觉通道，非常容易被人眼识别。从一堆正方形中识别出一个三角形，或看万绿丛中一点红，都是我们眼睛拿手好戏。</li>
<li><strong>定量性质或定序性质</strong>。适用于有序型和类别型数据。比如长度、大小特别适合于编码数值/量的大小。</li>
<li><strong>分组性质</strong>。具有相同视觉通道的数据，人眼也能很快识别出来，将其归为一组。</li>
</ol>
<p>总结一下视觉通道与数据类型的对应关系，如下图所示：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/level.png" alt="视觉通道与数据类型的对应"></p>
<h3 id="视觉编码设计的两大原则"><a href="#视觉编码设计的两大原则" class="headerlink" title="视觉编码设计的两大原则"></a>视觉编码设计的两大原则</h3><p>Mackinlay[4] 和 Tversky[5] 分别提出了两套可视化设计的原则，Mackinlay 强调表达性和有效性，Tversky 强调一致性和理解性。两者可以糅合起来：</p>
<ol>
<li><strong>表达性、一致性</strong>：可视化的结果应该充分表达了数据想要表达的信息，且没有多余。</li>
<li><strong>有效性、理解性</strong>：可视化之后比前一种数据表达方案更加有效，更加容易让人理解。</li>
</ol>
<p>下面这张图总结了视觉编码面对不同数据类型的优先级：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/level2.png" alt="视觉编码面对不同数据类型的优先级"></p>
<p>如果要具体展开每项视觉通道来说，未免有点太繁琐，而且设计可视化编码除了视觉通道还需要考虑：</p>
<ul>
<li>色彩搭配</li>
<li>交互</li>
<li>美学因素</li>
<li>信息的密度</li>
<li>直观映射、隐喻</li>
</ul>
<p>以上每一项都很重要，之后有机会再写吧。这个可视化基础系列总算是完结了，文字虽然不多，但是搜索资料、读论文、总结等还是挺累的，希望你能有所收获。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]Bertin J. Semiology of graphics: diagrams[C]// Conference on Computer Networks. 1983.</li>
<li>[2]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[3]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
<li>[4]Mackinlay, Jock. Automating the design of graphical presentations of relational information[J]. Acm Transactions on Graphics, 1986, 5(2):110-141.</li>
<li>[5]Tversky B, Morrison J B, Betrancourt M. Animation: Can it facilitate?[J]. International Journal of Human-Computer Studies, 2002, 57(4):247-262.</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第三篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/03/basics-of-data-visualization-visu
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——数据模型</title>
    <link href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html"/>
    <id>http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html</id>
    <published>2017-01-02T04:01:48.000Z</published>
    <updated>2017-01-10T05:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第二篇，主要介绍<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>，建议从可视化流程看起。<br>原文地址：<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html</a></p>
</blockquote>
<p>数据说白了就是一组可定性或可量化的值。随着计算机存储能力的大幅提高，人们对于数据的关注与日俱增，「大数据」一词近几年来也被人们频频提及。而数据可视化的主要任务是将数据转换为易于感知的图形。因此，为了更准确更形象的表达数据，我们需要了解一些数据相关的概念。</p>
<h2 id="数据模型与概念模型"><a href="#数据模型与概念模型" class="headerlink" title="数据模型与概念模型"></a>数据模型与概念模型</h2><p>为什么数据能代表我们的世界？要回答这个问题，我们得先了解数据和概念两个模型。</p>
<p><strong>数据模型</strong>是一组数字或符号的组合，它包含数据的定义、类型等，可以进行各类数学操作等。<strong>概念模型</strong>描述的是事物的语义或状态行为等。</p>
<p><strong>现实</strong> =&gt; <strong>概念</strong> =&gt; <strong>数据</strong></p>
<p>现实世界可以用概念模型来描述，而概念模型又可以用数据模型来描述。经过两层抽象，数据便可以描述我们的现实生活中的方方面面。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>一个东西具体归为哪一类，取决于我们用什么标准划分，数据亦然。</p>
<p>从数据在计算机中的存储可分为浮点数、整数、字符等；从关系模型的角度分，数据又可以分为实体和关系两类；从数据的结构来分，可以分为一维、二维、三维、多维、时间序列、空间序列、树型、图型等等[3]；还有很多的分类方法，我们暂时先不讨论，把关注点聚焦到和数据可视化有关的分类方法上。</p>
<p>按照测量标度来分，数据一般被分为四类：<strong>类别型</strong>、<strong>有序型</strong>、<strong>区间型</strong>、<strong>比值型</strong>。</p>
<ul>
<li><strong>类别型</strong>数据用于区分事物。例如，人可以分为男女，水果能分为苹果香蕉等。</li>
<li><strong>有序型</strong>用来表示对象间的顺序关系。例如，我们的身高可以从矮到高，学生的成绩可以从低到高排列等。</li>
<li><strong>区间型</strong>用于对象间的定量比较。例如，身高 160cm 与身高 170cm 相差 10cm，而 170cm 与 180cm 也相差 10cm，它们俩的差值是相等的。由此可见，区间型数据基于任意的起始点，所以它只能衡量对象间的相对差别。</li>
<li><strong>比值型</strong>用于比较数值间的比例关系。例如，体重 80kg 是体重 40kg 的两倍。</li>
</ul>
<p>不同的数据类型适用于不同的操作[1]：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">操作</th>
<th style="text-align:left">集合操作</th>
<th style="text-align:left">统计操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类别型</td>
<td style="text-align:left">=、≠</td>
<td style="text-align:left">互换元素位置</td>
<td style="text-align:left">类别、模式、列联相关</td>
</tr>
<tr>
<td style="text-align:left">有序型</td>
<td style="text-align:left">=、≠、&gt;、&lt;</td>
<td style="text-align:left">计算元素单调递增（减）</td>
<td style="text-align:left">中值、百分位数</td>
</tr>
<tr>
<td style="text-align:left">区间型</td>
<td style="text-align:left">=、≠、&gt;、&lt;、+、-</td>
<td style="text-align:left">元素间线性加（减）</td>
<td style="text-align:left">平均值、标准方差、等级相关、积差相关</td>
</tr>
<tr>
<td style="text-align:left">比值型</td>
<td style="text-align:left">=、≠、&gt;、&lt;、+、-、×、÷</td>
<td style="text-align:left">元素间相似度</td>
<td style="text-align:left">变异系数</td>
</tr>
</tbody>
</table>
<p>不过，在数据可视化中，我们通常不特别区分区间型和比值型，将其统称为<strong>数值型</strong>。进而可将数据类型进一步精简为三种：<strong>类别型</strong>、<strong>有序型</strong>、<strong>数值型</strong>。具体为什么要分为这三类，我相信你看完下一篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>之后会完全明白。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>说了那么多，都比较抽象，不如直接来看个例子。下面是一个简单的数据表，每一行通常称作一条<strong>记录</strong>，每一列称作一个<strong>字段</strong>，共有几个字段，则通常就说这份数据有几个<strong>维度</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">款式</th>
<th style="text-align:left">尺码</th>
<th style="text-align:left">销量</th>
<th style="text-align:left">年增长</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">男款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">L</td>
<td style="text-align:left">50</td>
<td style="text-align:left">10%</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">女款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">S</td>
<td style="text-align:left">35</td>
<td style="text-align:left">5%</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">女款</td>
<td style="text-align:left">裤子</td>
<td style="text-align:left">M</td>
<td style="text-align:left">40</td>
<td style="text-align:left">20%</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">男款</td>
<td style="text-align:left">上衣</td>
<td style="text-align:left">XL</td>
<td style="text-align:left">30</td>
<td style="text-align:left">15%</td>
</tr>
</tbody>
</table>
<p>对照我们上文的概念，不难判断出上表中：</p>
<ul>
<li>类型、款式为类别型数据；</li>
<li>id、尺码为有序型数据；</li>
<li>销量和年增长为数值型数据。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，其实本文的任务就已经完成了。通篇传递的最重要的知识就是数据可视化中的三大数据类型，消化了这点，下一篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>就能更好的理解。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[2]<a href="http://www.cad.zju.edu.cn/home/vagblog/?page_id=1302" target="_blank" rel="external">浙江大学-陈为、巫英才数据可视化课程</a></li>
<li>[3]Shneiderman B. The eyes have it: a task by data type taxonomy for information visualizations[C]// Visual Languages, 1996. Proceedings. IEEE Symposium on. IEEE Xplore, 1996:336-343.</li>
<li>[4]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第二篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/02/basics-of-data-visualization-data
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化基础——可视化流程</title>
    <link href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html"/>
    <id>http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html</id>
    <published>2017-01-01T09:35:36.000Z</published>
    <updated>2017-01-13T14:00:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第一篇，主要介绍<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">可视化流程</a>，另两篇则主讲<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>。<br>原文地址：<a href="http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html">http://geekplux.com/2017/01/01/basics-of-data-visualization-the-process-model.html</a></p>
</blockquote>
<p>很多人认为数据可视化非常简单，无非是输入几组数据，生成简单的条形图、直线图等等。然而，这未免有点管中窥豹。其实数据可视化大致可分为<strong>信息可视化</strong>、<strong>科学可视化</strong>和<strong>可视化分析</strong>三大类，刚才提到的简单图表只是信息可视化中最常见的几种。一旦数据量增大，可视化目标改变，可视化系统的复杂度可能就会超出我们的想象。本文中涉及到的可视化流程模型适用于信息可视化和科学可视化。可视化分析的流程模型略有不同，本文暂时不进行讨论。</p>
<h2 id="通用的可视化流程"><a href="#通用的可视化流程" class="headerlink" title="通用的可视化流程"></a>通用的可视化流程</h2><p>做任何事都有一个流程，可视化也不例外。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/Screen%20Shot%202017-01-01%20at%2018.04.55.png" alt="数据可视化流程总览"></p>
<p>一图以蔽之。可视化整体可分为三步：<strong>分析</strong>-<strong>处理</strong>-<strong>生成</strong>。</p>
<h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><p>进行一个可视化任务时，我们首当其冲的当然是要分析，分析又分为三部分：任务、数据、领域。</p>
<p>首先我们要分析我们这次可视化的出发点和目标是什么。我们遇到了什么问题、要展示什么信息、最后想得出什么结论、验证什么假说等等。数据承载的信息多种多样，不同的展示方式会使侧重点有天壤之别。只有想清楚以上问题，才能确定我们要过滤什么数据、用什么算法处理数据、用什么视觉通道编码等等。</p>
<p>其次我们要分析我们的数据，这是至关重要的一步。因为每次可视化任务拿到的数据都是不同的，数据类型、数据结构均有变化，数据的维度也可能成倍增加。抽象的数据类型如何对应现实中的概念，不同的数据类型如何进行视觉编码，这些我们在下一篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>中进行介绍。</p>
<p>最后我们针对不同的领域，也要进行相应的分析。毕竟术业有专攻，可视化的侧重点要跟着领域做出相应的变化。</p>
<h3 id="二、处理"><a href="#二、处理" class="headerlink" title="二、处理"></a>二、处理</h3><p>处理可以分为两部分：<strong>对数据的处理</strong>和<strong>对视觉编码的处理</strong>。</p>
<h4 id="1-数据处理"><a href="#1-数据处理" class="headerlink" title="1.数据处理"></a>1.数据处理</h4><p>在可视化之前我们要对数据进行数据清洗、数据规范、数据分析。</p>
<p>数据清洗和规范是必不可少的步骤。首先把脏数据、敏感数据过滤掉，其次再剔除和我们目标无关的冗余数据，最后调整数据结构到我们系统能接受的方式。</p>
<p>数据分析中最简单的方法当然是一些基本的统计方法，如求和、中值、方差、期望等等；复杂的方法有数据挖掘种的各种算法，这是又一个领域了，在此不赘述。</p>
<p>最后的可视化结果中我们肯定不可能把所有的数据统统展示出来，于是又涉及到包括标准化（归一化）、采样、离散化、降维、聚类等数据处理的方法，这些概念之后可以单独写篇文章来介绍。</p>
<h4 id="2-设计视觉编码"><a href="#2-设计视觉编码" class="headerlink" title="2.设计视觉编码"></a>2.设计视觉编码</h4><p>视觉编码的设计是指如何使用位置、尺寸、灰度值、纹理、色彩、方向、形状等视觉通道，以映射我们要展示的每个数据维度。这里看不懂没关系，第三篇<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>中会详细介绍。</p>
<h3 id="三、生成"><a href="#三、生成" class="headerlink" title="三、生成"></a>三、生成</h3><p>这个阶段基本上就是把之前的分析和设计付诸实践，在制作或写代码过程中，再不断调整需求、不断地迭代（有可能要重复前两步），最后产出我们想要的结果。</p>
<h2 id="其它可视化流程"><a href="#其它可视化流程" class="headerlink" title="其它可视化流程"></a>其它可视化流程</h2><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>1990 年 Robert B. Haber 和 David A. McNabb 提出的数据可视化流程已经非常先进：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/conceptual-model.png" alt="Haber, R. B. and McNabb, D. A. Visualization idioms: A conceptual model for scientific visualization systems, 1990."></p>
<p>这个处理模型非常先进，整个流程是线性的。它把数据分成五大阶段，分别要经历四个流程，每个过程的输入是上一个过程的输出。从图上看非常直观，很好理解。</p>
<h3 id="嵌套模型"><a href="#嵌套模型" class="headerlink" title="嵌套模型"></a>嵌套模型</h3><p>另一种模型是嵌套模型：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/nested-model.png" alt="Munzner T. A Nested Process Model for Visualization Design and Validation\[J\]. IEEE Transactions on Visualization &amp; Computer Graphics, 2009, 15(6):921-8."></p>
<p>嵌套模型的上半部分基本上就是我们之前说的分析、处理两步，下半部分是对可视化结果的各类验证。本质上就是一个验证加迭代的过程。我们知道很多事都不是一蹴而就的，需要不断迭代，所以有人提出了循环模型。</p>
<h3 id="循环模型"><a href="#循环模型" class="headerlink" title="循环模型"></a>循环模型</h3><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/cyclical-model-1.png" alt="Stolte C, Hanrahan P. Polaris: a system for query, analysis and visualization of multi-dimensional relational databases[C]// IEEE Symposium on Information Visualization. 2000:5-14."></p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/cyclical-model-2.png" alt="Wijk J J V. The Value of Visualization[C]// Visualization, 2005. VIS 05. IEEE. 2005:11-11."></p>
<p>循环模型的两张图其实都是把线性模型首尾连起来，从图上看一目了然。</p>
<h3 id="目前应用最广的模型"><a href="#目前应用最广的模型" class="headerlink" title="目前应用最广的模型"></a>目前应用最广的模型</h3><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/basics-of-data-visualization/best-process-model.png" alt="Card S K, Mackinlay J D, Shneiderman B. Readings in information visualization: using vision to think[M]// Readings in information visualization :. Morgan Kaufmann Publishers, 1999:647-650."></p>
<p>对比之前的线性模型，其实也很类似，不过其在最后加入了用户交互的部分，且让每个步骤都变成了循环的。这是目前应用最广的可视化流程模型，后继几乎所有著名的信息可视化系统和工具都支持、兼容这个模型。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纵观以上提到的各类模型，都非常类似，本质上还是离不开<strong>分析</strong>-<strong>处理</strong>-<strong>生成</strong>三步，所以掌握第一张图就可以了，以不变应万变。文中多次提到视觉编码、数据处理等概念，我们在接下来的两篇<a href="http://geekplux.com/2017/01/02/basics-of-data-visualization-data-model.html">数据模型</a>和<a href="http://geekplux.com/2017/01/03/basics-of-data-visualization-visual-encoding-principles.html">视觉编码</a>介绍。欢迎各位在我博客文末留言讨论（如果看不到评论框可能是因为你没有科学上网）。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>[1]<a href="https://book.douban.com/subject/25760272/" target="_blank" rel="external">陈为 沈则潜 陶煜波. 数据可视化[M]. 电子工业出版社, 2013.</a></li>
<li>[2]<a href="http://www.cad.zju.edu.cn/home/vagblog/?page_id=1302" target="_blank" rel="external">浙江大学-陈为、巫英才数据可视化课程</a></li>
<li>[3]Haber, R. B. and McNabb, D. A. Visualization idioms: A conceptual model for scientific visualization systems, 1990.</li>
<li>[4]Munzner T. A Nested Process Model for Visualization Design and Validation[J]. IEEE Transactions on Visualization &amp; Computer Graphics, 2009, 15(6):921-8.</li>
<li>[5]Stolte C, Hanrahan P. Polaris: a system for query, analysis and visualization of multi-dimensional relational databases[C]// IEEE Symposium on Information Visualization. 2000:5-14.</li>
<li>[6]Wijk J J V. The Value of Visualization[C]// Visualization, 2005. VIS 05. IEEE. 2005:11-11.</li>
<li>[7]Card S K, Mackinlay J D, Shneiderman B. Readings in information visualization: using vision to think[M]// Readings in information visualization :. Morgan Kaufmann Publishers, 1999:647-650.</li>
<li>[8]<a href="http://courses.cs.washington.edu/courses/cse512/16sp/" target="_blank" rel="external">CSE512 Data Visualization (Spring 2016)</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本系列「数据可视化基础」文章共三篇，介绍可视化中最基础、最重要的一些概念、理论。这篇为第一篇，主要介绍&lt;a href=&quot;http://geekplux.com/2017/01/01/basics-of-data-visualization-the-
    
    </summary>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Visualization/"/>
    
    
      <category term="Guide" scheme="http://geekplux.com/tags/Guide/"/>
    
      <category term="入门" scheme="http://geekplux.com/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据可视化" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="大数据" scheme="http://geekplux.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Big Data" scheme="http://geekplux.com/tags/Big-Data/"/>
    
      <category term="Data" scheme="http://geekplux.com/tags/Data/"/>
    
      <category term="Data Visualization" scheme="http://geekplux.com/tags/Data-Visualization/"/>
    
      <category term="Note" scheme="http://geekplux.com/tags/Note/"/>
    
      <category term="笔记" scheme="http://geekplux.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>为什么要用 Emacs</title>
    <link href="http://geekplux.com/2016/12/03/why-use-emacs.html"/>
    <id>http://geekplux.com/2016/12/03/why-use-emacs.html</id>
    <published>2016-12-03T07:22:17.000Z</published>
    <updated>2016-12-04T07:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文仅从作者个人感受上谈一下自己使用 Emacs 的理由和感受，通篇无干货。</p>
</blockquote>
<p>Emacs 和 Vim 这两大编辑器，一直让前赴后继的工具党难以取舍。到底学哪一个？哪一个学了之后能如虎添翼？最初的我也是纠结了许久，仿佛本科时纠结到底该主学 C++ 还是主学 Java 一样。而事实上正如前辈们说的：<em>不要纠结学哪个，反正迟早都要学</em>。</p>
<h2 id="使用-Emacs-的若干好处"><a href="#使用-Emacs-的若干好处" class="headerlink" title="使用 Emacs 的若干好处"></a>使用 Emacs 的若干好处</h2><p>从我个人的角度讲，我认为学习和使用 Emacs 有以下几个好处：</p>
<ul>
<li><strong>掌握了一个几乎能完成任何事，又可以随心所欲修改的编辑器</strong></li>
<li><strong>入了 lisp 的门</strong></li>
<li><strong>混进了一个牛人众多的社区</strong></li>
</ul>
<p>搜索过 Emacs 的人对前两点应该都有所耳闻，但百闻不如一见，真正使用之后才知道 Emacs 多强大。就我个人来说，除了将 Emacs 作为多种编程语言的编辑器，还用来管理自己的<a href="http://geekplux.com/wiki">学习笔记</a>、To-Do List。社区里很多道友还用它来记账、管理文献、写论文等等（<em><a href="https://emacs-china.org/t/emacs/61" target="_blank" rel="external">大家都用 Emacs 做什么？</a></em>）。如果你对 Emacs 没兴趣，那么至少应该了解一下 <a href="http://orgmode.org/" target="_blank" rel="external">Org-Mode</a>，由于 Org-Mode 的强大，有人甚至用它来<a href="http://doc.norang.ca/org-mode.html" target="_blank" rel="external">管理自己的一生</a>（<em>类似<a href="https://book.douban.com/subject/1115353/" target="_blank" rel="external">《奇特的一生》</a>中提到的方法</em>）。Org 其实就像 MarkDown 一样，是一种标记语言，想想能用纯文本去管理自己的一生，是不是还有点小激动。</p>
<p><img src="https://emacs-china.org/uploads/default/original/1X/606931976e4756474b5654f33e74171250d63c3e.jpeg" alt="用 Emacs 查看天气"></p>
<p>由于 Emacs 的配置都是用 elisp 这个 lisp 的方言去写的，所以学习 lisp 终于有了用武之地。不过 lisp 属于「规则简单，威力无穷」，学习它其实不会花太多时间，但要理解它的精髓和使用好它真的很难。</p>
<p>除了以上两点，还有一个最关键的好处是：认识了很多牛人。不得不说，<strong>Emacs 的高门槛和小众，决定了其使用者的质量</strong>。很多 Emacs 道友来自非计算机行业，有的学化学，有的做木工，非常有趣。而且大家都特别有钻研精神，这可能也是所有 Emacs 玩家的共同点。</p>
<h2 id="我是如何中了-Emacs-的毒"><a href="#我是如何中了-Emacs-的毒" class="headerlink" title="我是如何中了 Emacs 的毒"></a>我是如何中了 Emacs 的毒</h2><p>其实最早听说 Emacs 是在本科的时候。下载下来拨弄一番后发现难点在于记忆快捷键，实现一个自己想要的操作可能需要按一系列按键，有点像<strong>记忆菜单栏快捷键</strong>的感觉（<em>现在不这么认为了，现在完成一个操作我可能都是直接调用 Emacs 的函数，因为 Emacs 中任何一个操作其实都是一个函数</em>）。每一个快捷键组合打开一个「子菜单」，最终要实现的操作有可能在三级子菜单中，所以感觉相当繁琐。后来每每雄心壮志重新开始学习，都会被记忆快捷键这个拦路虎挡住。</p>
<p>当然，学习 Vim 也如此。在不知道多少次折腾后，我还是先掌握了 Vim，学习历程和方式参见这篇 <a href="http://geekplux.com/2015/06/06/vim-those-fit-yourself-are-the-best.html">Vim - 适合自己的，才是最好的</a>。Vim 的哲学和 Emacs 不同，它把输入分成 <strong>纯输入</strong> 和 <strong>操作</strong> 两种模式（个人理解）。纯输入就是单纯的输入字符，需要换行、移动光标、复制粘贴时则需要「操作」。我觉得这种很符合大脑的思考方式，输入时单纯想着内容就好，需要「整理」内容时再操作。</p>
<p>但是我想用 Emacs 之心不死，当时主要因为 Org-Mode 对我的吸引力很大。在听说 Emacs 有 evil 之后，果断转了过去，瞬间觉得学习曲线变得顺滑了。再之后发现了颜值颇高的 Spacemacs，于是更加爱不释手。Spacemacs 的文档非常详尽，还提供了如何从 Vim 迁移的方案，对我这种菜鸟真的是非常友好。</p>
<p>从此，便算是入了坑，之后的填坑之路也是漫长，比如如何配置，如何使用 Org-Mode，如何寻找适合自己的最佳实践，每部分都能长篇大论一番。</p>
<p>如果你有兴趣，还可以去 <a href="https://emacs-china.org/t/emacs-joy/80" target="_blank" rel="external">来聊聊大家是怎么入 Emacs 这个大坑的吧</a> 看看其他人入坑的经历。</p>
<h3 id="关于-Emacs-的学习曲线"><a href="#关于-Emacs-的学习曲线" class="headerlink" title="关于 Emacs 的学习曲线"></a>关于 Emacs 的学习曲线</h3><p>有的人推崇从最原生的 Emacs 学起，自己一步步配置，有的人推崇直接用社区大牛写好的配置，我显然是后者。<a href="https://github.com/syl20bnr/spacemacs/" target="_blank" rel="external">Spacemacs</a> 就是一款对新手和 Vim 党非常友好的配置，而且文档写的<strong>特别详细</strong>，只要你<strong>耐心</strong>读，绝对是可以从容掌握它的，实在遇到困难可以在社区<strong>正确</strong>提问，只要你问题不是很让人反感，都会有很多大牛热心帮你（<em>这里我不禁要说一句，如果你是伸手党，那么 Emacs 是真的不适合你</em>）。</p>
<h3 id="关于使用-Emacs-太折腾"><a href="#关于使用-Emacs-太折腾" class="headerlink" title="关于使用 Emacs 太折腾"></a>关于使用 Emacs 太折腾</h3><p>刚开始确实花很多时间在折腾上，但是现在不会了。因为我发现，对工具「折腾」的越多，定制越深，就会越<strong>依赖</strong>这个工具。一旦需要在别的电脑上编程，双手都感觉不是自己的了。同时，折腾后的「效率提升」其实我们自己都知道效果并不明显，有的需求完全是<strong>伪需求</strong>。强迫自己适应一个新的操作方式，虽然对自己是一个训练，但不需要以提升效率为借口。所以我现在基本上除了一些影响使用上的改动外，基本上维持默认配置，强迫自己适应默认配置，适应才是对效率的最大提升。</p>
<p>不过，一旦开始折腾，很容易<strong>停不下来</strong>，你懂的。。。一下午甚至一天的时间一瞬间就没了。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul>
<li><a href="https://emacs-china.org/t/emacs/111" target="_blank" rel="external">编辑器辣么多，为什么你还在使用 Emacs?</a></li>
<li><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org" target="_blank" rel="external">一年成为Emacs高手(像神一样使用编辑器)</a></li>
<li><a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="external">Spacemacs Rocks 21 天掌握 Emacs</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文仅从作者个人感受上谈一下自己使用 Emacs 的理由和感受，通篇无干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Emacs 和 Vim 这两大编辑器，一直让前赴后继的工具党难以取舍。到底学哪一个？哪一个学了之后能如虎添翼？最初的我也是纠结了
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Vim" scheme="http://geekplux.com/tags/Vim/"/>
    
      <category term="Emacs" scheme="http://geekplux.com/tags/Emacs/"/>
    
      <category term="IDE" scheme="http://geekplux.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Vega-Lite: A Grammar of Interactive Graphics</title>
    <link href="http://geekplux.com/2016/11/02/vega-lite-a-grammar-of-interactive-graphics.html"/>
    <id>http://geekplux.com/2016/11/02/vega-lite-a-grammar-of-interactive-graphics.html</id>
    <published>2016-11-02T08:16:16.000Z</published>
    <updated>2016-12-03T10:29:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在 InfoVis 2016 上，<a href="http://idl.cs.washington.edu/" target="_blank" rel="external">UW 交互数据实验室</a> 提出了一种新的交互数据可视化语法——Vega-Lite，获得了今年的 best paper，本文将根据其论文从多个角度介绍 Vega-Lite。<a href="http://idl.cs.washington.edu/papers/vega-lite/" target="_blank" rel="external">论文地址</a></p>
</blockquote>
<h2 id="什么是-Vega-Lite"><a href="#什么是-Vega-Lite" class="headerlink" title="什么是 Vega-Lite"></a>什么是 Vega-Lite</h2><p>简而言之，<a href="https://vega.github.io/vega-lite/" target="_blank" rel="external">Vega-Lite</a> 是一种数据可视化的高级语法，能够快速定义一些基本的交互式数据可视化。</p>
<p>如果你听说过 <a href="https://vega.github.io/vega/" target="_blank" rel="external">Vega</a>，那么光看 Vega-Lite 的名字就不难想到它们的关系。Vega-Lite 就是编译成 Vega 的更高级图形语法。</p>
<p>如下图所示，只要右边寥寥数行代码，就能定义一个散点图：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/sctterplot1.png" alt=""></p>
<h2 id="为什么要提出-Vega-Lite"><a href="#为什么要提出-Vega-Lite" class="headerlink" title="为什么要提出 Vega-Lite"></a>为什么要提出 Vega-Lite</h2><p>首先，Vega-Lite 的目标是：</p>
<ul>
<li>通过一种规范来快速的表达你的可视化设计。</li>
<li>提供了简洁的语法和图元便于你快速切换设计。</li>
</ul>
<p>以前的东西做不到吗？其实也不是做不到，只是在有些方面还有很大的提升空间，Vega-Lite 就是在这个方向上很大的一步棋：</p>
<ul>
<li>低等级的可视化语法有更高的自由度，但往往高等级的可视化语言更受偏爱，主要因为其简洁，能快速做出东西，而且能生成低等级的语法供二次开发（Vega-Lite 可以编译成 Vega，而且所有代码都是 JSON 格式）。</li>
<li>低等级的可视化语言没法提供现成的可视化方案（得你自己设计），而高等级的可以直接搜索或推断出适合你的可视化方案，支持在线查看效果（比如用 vega-lite 配套的 Voyager）。</li>
<li>从交互方面来说，现有的高级语法在交互方面比较局限，而低等级语法可能为了定制化还得自己去处理事件回调（例如 D3），这对非专家很不友好且很容易出错。而 Vega-Lite 直接提供更简洁更具表现力的交互（一两行代码就能定义一个交互操作）。</li>
</ul>
<p>为了实现以上的这些愿景，Vega-Lite 主要通过以下方式做出努力：</p>
<ul>
<li><strong>Algebra</strong>  用于将单个 view 合成多 view</li>
<li><strong>Selection</strong> 用于交互选择判定</li>
<li><strong>Transform</strong> 对数据、交互操作转换</li>
<li><strong>Compiler</strong> 编译成 vega 语言，可供二次开发</li>
</ul>
<p>接下来说说它怎么具体实现上面这四个概念的。</p>
<h2 id="Vega-Lite-的具体语法"><a href="#Vega-Lite-的具体语法" class="headerlink" title="Vega-Lite 的具体语法"></a>Vega-Lite 的具体语法</h2><p>可以从两个方面分开介绍，分别是图形方面和交互方面。</p>
<h3 id="Vega-Lite-的具体语法——图形方面"><a href="#Vega-Lite-的具体语法——图形方面" class="headerlink" title="Vega-Lite 的具体语法——图形方面"></a>Vega-Lite 的具体语法——图形方面</h3><h4 id="View-视图"><a href="#View-视图" class="headerlink" title="View 视图"></a>View 视图</h4><p>首先，Vega-Lite 定义一个图形为一个 Unit，所以 Unit 是 Vega-Lite 里图形的最小单位。Unit 的定义是：</p>
<pre><code>unit := (data, transforms, mark-type, encodings)
</code></pre><ul>
<li>data 用来说明数据的来源，支持JSON格式和CSV格式</li>
<li>transform 定义了如何对原始输入数据进行处理</li>
<li>mark 指定了可视化图形</li>
<li>encoding 定义数据到可视化图形的映射规则</li>
</ul>
<p>可视化中视觉通道的设计非常重要，所以其中，encoding 是比较重要的。</p>
<pre><code>encoding := (channel, field, data-type, value, functions, scale, guide)
</code></pre><p>每个 Unit 可以通过一些 operators 变成 View，而 View 又可以通过一些 operators 变成复合的 View。</p>
<p>所以可以这么理解，你每个 operator 的单位是一个视图（可以是 Unit，也可以是 View），而一个 operator 的输出又可以作为下一个 operator 的输入，进而可以形成一个嵌套视图。</p>
<h4 id="Operators-操作"><a href="#Operators-操作" class="headerlink" title="Operators 操作"></a>Operators 操作</h4><p>刚才提到了 operators，你可以把一个 operator 理解成<strong>该以何种方式来整合视图</strong>。Vega-Lite 一共提供了四种 operators，分别是 Layer、Concatenation、Facet、Repeat。</p>
<h5 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h5><p>Layer 很好理解，就是字面意思，将每个 View 重叠；</p>
<pre><code>layer([unit1, unit2, ...], resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/layer.png" alt=""></p>
<h5 id="Concatenation"><a href="#Concatenation" class="headerlink" title="Concatenation"></a>Concatenation</h5><p>Concatenation是将多个单视图水平放置或垂直放置；</p>
<pre><code>hconcat([view1, view2, ...], resolve)
vconcat([view1, view2, ...], resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/concatenation.png" alt=""></p>
<h5 id="Facet"><a href="#Facet" class="headerlink" title="Facet"></a>Facet</h5><p>Facet 是将多个单视图根据数据中的某个 field 进行排布；</p>
<pre><code>facet(channel, data, field, view, scale, axis, resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/facet.png" alt=""></p>
<h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p>Repeat 也很好理解，重复放置视图。</p>
<pre><code>repeat(channel, values, scale, axis, view, resolve)
</code></pre><p><img src="http://7b1evr.com1.z0.glb.clouddn.com/repeat.png" alt=""></p>
<h3 id="Vega-Lite-的具体语法——交互方面"><a href="#Vega-Lite-的具体语法——交互方面" class="headerlink" title="Vega-Lite 的具体语法——交互方面"></a>Vega-Lite 的具体语法——交互方面</h3><p>任何交互中，<strong>选择</strong>一直是最重要的一个概念，所以 Vega-Lite 的所有交互也都围绕一个概念 —— Selection。首先看 Selection 的定义：</p>
<pre><code>selection := (name, type, predicate, domain|range, event, init, transforms, resolve)
</code></pre><ul>
<li>name: 属性名</li>
<li>type: point, list, intervel</li>
<li>predicate: 决定符合条件的最小集合（判定哪些东西被选进来）</li>
<li>event: 事件如何定义</li>
<li>transform: 操作已选择的元素</li>
</ul>
<p>其中 transform 又最为重要，它定义了已选择之后的操作。这些操作可以进行随机的组合，且用户不需要定义操作之间的先后顺序，因为具体的顺序由编译器定义。</p>
<p>Vega-Lite 目前提供的交互操作一共有 5 种，分别是：project(fields, channels)、toggle(event)、translate(events, by)、zoom(event, factor)、nearest()。</p>
<h5 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h5><p>Project 用来重定义判定函数 predicate。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/project.png" alt=""></p>
<h5 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h5><p>Toggle 表示按下shift键，可以在之前交互结果上，继续进行交互。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/toggle.png" alt=""></p>
<h5 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h5><p>Translate 用于改变交互事件的判断</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/translate.png" alt=""></p>
<h5 id="Zoom-和-Nearest"><a href="#Zoom-和-Nearest" class="headerlink" title="Zoom 和 Nearest"></a>Zoom 和 Nearest</h5><ul>
<li>Zoom操作主要用户视图的缩放</li>
<li>Nearest操作，会将整个视图根据元素的位置分割成Voronoi图，然后将距当前交互的元素最近的元素选择出来</li>
</ul>
<h4 id="其他交互"><a href="#其他交互" class="headerlink" title="其他交互"></a>其他交互</h4><h5 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if-then-else"></a>if-then-else</h5><p>简单的条件判断逻辑。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/select.png" alt=""></p>
<h5 id="把选择的数据作为另一个-view-的输入"><a href="#把选择的数据作为另一个-view-的输入" class="headerlink" title="把选择的数据作为另一个 view 的输入"></a>把选择的数据作为另一个 view 的输入</h5><p>上文也说到过，可以理解成视图的嵌套，也可以用作多视图协作。</p>
<h5 id="根据选择的数据设置的比例尺"><a href="#根据选择的数据设置的比例尺" class="headerlink" title="根据选择的数据设置的比例尺"></a>根据选择的数据设置的比例尺</h5><p>结合上一点，就可以把一个视图作为另一个视图的拓展。例如下图的 Overview + Detail 模式。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/detail.png" alt=""></p>
<p><strong>以上三个交互情形都支持与或非逻辑</strong></p>
<h5 id="多视图交互中的歧义"><a href="#多视图交互中的歧义" class="headerlink" title="多视图交互中的歧义"></a>多视图交互中的歧义</h5><p>单视图中的交互，很可能在多视图中引发歧义。例如，在散点图矩阵中，如果在一个矩阵中进行 brush，其他的矩阵怎么配合协作？于是 Vega-Lite 又定义了四种交互协作模式，分别是 single、independent、union、intersect。</p>
<ul>
<li>默认是 single，用户在某个视图中进行交互，其他视图不会做出响应。</li>
<li>其次是 independent，每个视图中的交互互不影响。</li>
<li>union 求并集，是指只要在多视图中任意一个子视图选中的部分，就被算作选中。</li>
<li>intersect 求交集，是指只有在多视图中都选中的部分，才被算作选中。</li>
</ul>
<h3 id="Vega-Lite-编译器"><a href="#Vega-Lite-编译器" class="headerlink" title="Vega-Lite 编译器"></a>Vega-Lite 编译器</h3><p>Vega-Lite 虽然也是用 JSON 写，但它可以编译成更低级的 Vega。其中它的编译器面临两个难点：</p>
<h4 id="两个难点"><a href="#两个难点" class="headerlink" title="两个难点"></a>两个难点</h4><ul>
<li>数据结构不对应</li>
<li>由于vega-lite省略了很多细节设定，所以得编译器自己计算</li>
</ul>
<h4 id="四个步骤"><a href="#四个步骤" class="headerlink" title="四个步骤"></a>四个步骤</h4><p>编译器用四个步骤解决了以上两个难点。</p>
<ul>
<li>语法分析，消除歧义</li>
<li>建立 vega-lite 和 vega 数据结构间的联系</li>
<li>组合、优化数据结构，去除冗余</li>
<li>汇编所有的元素</li>
</ul>
<h2 id="Vega-Lite-局限性"><a href="#Vega-Lite-局限性" class="headerlink" title="Vega-Lite 局限性"></a>Vega-Lite 局限性</h2><p>Vega-Lite 目前虽然已经发布，但依旧在紧锣密鼓的开发，主要是因其现在还没有达到其理想的效果，在以下两方面还有局限性：</p>
<ul>
<li>生成的可视化结果依赖于当前 Vega-Lite 的实现（未来可能会通过解释器层面解决，而不是编译器）</li>
<li>本身固有的模式（通过 predicate function 抽象来解决）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可视化在时下越来越重要，越来越多的行业需要对数据进行展示，而可视化的专家又少之又少，所以很需要一款像 Vega-Lite 一样，简单，智能的系统快速地实现可视化。这可能是可视化工具未来发展的方向 —— 快速实现，快速替换可视化方案，快速展示，接下来再进行二次开发，进而多次迭代。</p>
<p>由此可见 Vega-Lite 前景很大，不过可能还需要再沉淀、开发一段时间，我们拭目以待吧。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Satyanarayan, A., Moritz, D., Wongsuphasawat, K., &amp; Heer, J. (2016). Vega-Lite: A Grammar of Interactive Graphics. IEEE Transactions on Visualization and Computer Graphics, 2626(c), 1–1. <a href="http://doi.org/10.1109/TVCG.2016.2599030" target="_blank" rel="external">http://doi.org/10.1109/TVCG.2016.2599030</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 InfoVis 2016 上，&lt;a href=&quot;http://idl.cs.washington.edu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;UW 交互数据实验室&lt;/a&gt; 提出了一种新的交互数据可视化语法——Veg
    
    </summary>
    
      <category term="Research" scheme="http://geekplux.com/categories/Research/"/>
    
      <category term="Visualization" scheme="http://geekplux.com/categories/Research/Visualization/"/>
    
    
      <category term="Visualization" scheme="http://geekplux.com/tags/Visualization/"/>
    
      <category term="可视化" scheme="http://geekplux.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="数据" scheme="http://geekplux.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="Research" scheme="http://geekplux.com/tags/Research/"/>
    
      <category term="交互" scheme="http://geekplux.com/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="Graphics" scheme="http://geekplux.com/tags/Graphics/"/>
    
      <category term="Vega" scheme="http://geekplux.com/tags/Vega/"/>
    
      <category term="Vega-Lite" scheme="http://geekplux.com/tags/Vega-Lite/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建一个私人网盘</title>
    <link href="http://geekplux.com/2016/10/25/how-to-setup-a-personal-cloud.html"/>
    <id>http://geekplux.com/2016/10/25/how-to-setup-a-personal-cloud.html</id>
    <published>2016-10-25T14:13:11.000Z</published>
    <updated>2016-11-02T10:17:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>文章主要讲了为什么要搭建私有网盘，以及如何用 docker + ownCloud 搭建。</p>
</blockquote>
<p>前两天，360 云盘宣布将停止个人服务。一石激起千层浪，关于如何选择网盘，如何应对网盘关闭的讨论一下子又变得此起彼伏。没办法，目前的现状是，网盘很难有大的盈利空间，还面对严苛的内容审查和隐私保护，虽然于用户来说提供了便利，但于公司来说实在是一件出力不讨好的事情。</p>
<h2 id="之前的网盘方案"><a href="#之前的网盘方案" class="headerlink" title="之前的网盘方案"></a>之前的网盘方案</h2><p>国外的网盘我一直是三家一起用，分别是 Dropbox 存储代码和一些重要或私密文件；Google Drive 存储一些大文件和私密文件；OneDrive 存储一些电子书（同步太慢了）。国内的网盘我之前只用两家，一是坚果云，放一些个人常用的小文件，包括一些文档和软件配置文件；另一个是百毒云，放一些各处转存来的大文件、自己的照片和学习资料，一方面因其空间大，另一方面因其同步流畅。然而，百毒云前段时间把我的网盘<strong>全面封掉</strong>了，丢失了很多大学时的照片（其它文件要不不重要，要不有备份），申诉无果，实属无奈。</p>
<h2 id="搭建一个只属于自己的网盘"><a href="#搭建一个只属于自己的网盘" class="headerlink" title="搭建一个只属于自己的网盘"></a>搭建一个只属于自己的网盘</h2><p>所以我决定搭建一个只属于自己的网盘。考察了几种方案（包括买 RAID 或 NAS 等），发现已有人在这方面做了努力，提供了像 <a href="https://www.seafile.com/home/" target="_blank" rel="external">Seafile</a> 和 <a href="https://owncloud.org/" target="_blank" rel="external">ownCloud</a> 这样的产品。接下来对比了两个软件，我决定选择用 ownCloud，主要出于以下几点考虑：</p>
<ul>
<li>可以设置是否加密，保证数据安全。</li>
<li>ownCloud 可以用于同步日程、联系人、浏览器书签等，最重要的是<strong>密码管理</strong>，这对于目前有无数密码需要记的我们非常实用。ownCloud 还有个应用商店，大家可以自行发现有用的应用。</li>
<li>ownCloud 提供网页和各种设备、系统的客户端（Windows、Mac、Linux、iOS、Android皆有）进行访问你的网盘。</li>
<li>ownCloud 能将外部存储（如 FTP、WebDAV、Amazon S3，甚至 Dropbox 和 Google Drive）的文件挂载到 ownCloud 上，实现无缝存储和分享。</li>
<li>文件支持版本管理，还有回收站，所以不必担心误删。</li>
</ul>
<h2 id="搭建方法"><a href="#搭建方法" class="headerlink" title="搭建方法"></a>搭建方法</h2><p>首先你得<strong>先有一个自己的 VPS</strong>。。没错，要不然你的数据往哪放，ownCloud 在哪运行。</p>
<p>有了 VPS 之后，就可以按照官网教程一步一步安装搭建了。然而，步骤相当繁琐，你得先安装 PHP、MySQL、 Apache 等等，所以我们要祭出神器 —— docker（这里就不介绍 docker 的用法了，以下内容默认大家对 docker 的基本使用有所了解）。这样一来，之前冗长的步骤，就化成了三步：</p>
<ol>
<li>安装 docker、docker-compose，下载 ownCloud 的 image</li>
<li>配置 docker-compose.yml</li>
<li>配置完毕，启动，打开 ownCloud 主界面配置数据库、管理员等</li>
</ol>
<blockquote>
<p><strong>下面是对上面三步的详细讲解，嫌太长的话可以不看。只需要把下面用到的两个 docker images （owncloud、postgres）下载好，安装 docker-compose 并拷贝 docker-compose.yml 文件到你想要存储 ownCloud 数据的文件夹，然后运行 <code>docker-compose up</code> 就好，一气呵成。</strong></p>
</blockquote>
<h3 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h3><p>安装好 docker 之后，直接下载 <code>owncloud</code> image 运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name owncloud -p 80:80 owncloud</div></pre></td></tr></table></figure>
<p>其实就可以看到 ownCloud 已经运行起来了，访问你的 VPS 地址，就可以看到 ownCloud 的界面。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/docker-owncloud-1.png" alt=""></p>
<p>但这时的 ownCloud 还没有数据库，所以我们还需要用 docker –link 来添加一个数据库存储 ownCloud 的数据，这里用到了 <code>postgres</code> 这个 image（数据库你可以自己定，不一定要用 postgreSQL）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run --name owncloud-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres</div><div class="line">docker run --rm --link owncloud-postgres:owncloud-db --name owncloud -p 80:80 owncloud</div></pre></td></tr></table></figure>
<p>第一条命令会启动一个 postgreSQL 数据库，默认的用户是 postgres，密码设为了 mysecretpassword，host 是 owncloud-db。</p>
<p>但这时我们运行的 docker container 一旦删掉，我们的数据就没有了，所以我们需要用 docker 中的 volumes (或 <a href="https://docs.docker.com/userguide/dockervolumes/#creating-and-mounting-a-data-volume-container" target="_blank" rel="external">docker data volumes</a>)来把 ownCloud 的数据持久化。</p>
<h3 id="配置-docker-compose"><a href="#配置-docker-compose" class="headerlink" title="配置 docker compose"></a>配置 docker compose</h3><p>这样一来，我们得启动两个 container 作为 data-only container，然后再启动 owncloud 和 postgres 关联这两个 data-only container，非常繁杂，幸亏我们有 <code>docker-compose</code> 帮忙。先安装它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install docker-compose</div></pre></td></tr></table></figure>
<p>然后配置 docker-compose.yml，下面配置中的 <code>volumes</code> 就是在配置数据持久化的目录结构。由于我把 docker-compose.yml 存在了VPS 的<code>~/owncloud</code>文件夹下，所以底下 <code>volumes</code> 配置中，冒号前面的宿主目录是那样写的，而冒号后面的是 container 中的目录，具体：</p>
<ul>
<li>/etc/postgresql 存储数据库的配置</li>
<li>/var/lib/postgresql 存储数据库中的数据</li>
<li>/var/www/html/app 存储 ownCloud APP 的数据</li>
<li>/var/www/html/data 存储 ownCloud 的数据</li>
<li>/var/www/html/config 存储 ownCloud 的配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Composition of the containers</span></div><div class="line"></div><div class="line"><span class="attr">postgres-data:</span></div><div class="line"><span class="attr">  image:</span> postgres</div><div class="line"><span class="attr">  command:</span> /bin/<span class="literal">true</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> ~/owncloud/etc/postgresql:/etc/postgresql</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/lib/postgresql:/var/lib/postgresql</div><div class="line"></div><div class="line"><span class="attr">owncloud-data:</span></div><div class="line"><span class="attr">  image:</span> owncloud</div><div class="line">  <span class="comment"># This is a data container, so we want to exit as soon as the container is created</span></div><div class="line">  <span class="comment"># BUT we will have to fix permissions issues first (33 is the ID of the www-data user)</span></div><div class="line"><span class="attr">  command:</span> /bin/bash -c <span class="string">"/bin/chown -R 33 /var/www/html/data &amp;&amp; /bin/chown -R 33 /var/www/html/config"</span></div><div class="line"><span class="attr">  volumes:</span></div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/apps:/var/www/html/apps</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/data:/var/www/html/data</div><div class="line"><span class="bullet">    -</span> ~/owncloud/var/www/html/config:/var/www/html/config</div><div class="line"></div><div class="line"><span class="attr">owncloud:</span></div><div class="line"><span class="attr">  image:</span> owncloud</div><div class="line"><span class="attr">  ports:</span></div><div class="line"><span class="bullet">    -</span> <span class="number">8080</span>:<span class="number">80</span></div><div class="line"><span class="attr">  volumes_from:</span></div><div class="line"><span class="bullet">    -</span> owncloud-data</div><div class="line"><span class="attr">  links:</span></div><div class="line"><span class="attr">    - postgres:</span>postgres</div><div class="line"><span class="attr">  hostname:</span> cloud</div><div class="line"><span class="attr">  domainname:</span> cloud.example.org <span class="comment"># Change to the hostname you will use</span></div><div class="line"></div><div class="line"><span class="attr">postgres:</span></div><div class="line"><span class="attr">  image:</span> postgres</div><div class="line"><span class="attr">  environment:</span></div><div class="line"><span class="bullet">    -</span> POSTGRES_USER=postgres</div><div class="line"><span class="bullet">    -</span> POSTGRES_PASSWORD=mypostgrespassword</div><div class="line"><span class="attr">  volumes_from:</span></div><div class="line"><span class="bullet">    -</span> postgres-data</div></pre></td></tr></table></figure>
<p>把 docker-compose.yml 配置好之后，只需运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-compose up</div></pre></td></tr></table></figure>
<p>就可以把 ownCloud 运行起来了，上一步中的很多操作，这里一步就搞定了。不过<strong>切记！<code>owncloud-data</code>和<code>postgres-data</code>两个 container 和 volume 千万不要删。删之前请备份</strong>。</p>
<h3 id="ownCloud-配置"><a href="#ownCloud-配置" class="headerlink" title="ownCloud 配置"></a>ownCloud 配置</h3><p>访问你 VPS 的 8080 端口（刚才配置文件里写了）打开 ownCloud 主页，需要做两件事</p>
<ol>
<li>输入管理员的账号和密码</li>
<li>选择数据库用哪个，且输入数据库配置，这里对照我们刚才 docker-compose 里的写的输入就好</li>
</ol>
<p>点击完成，一切 OK，进入文件页面尽情探索吧！</p>
<h2 id="参考-amp-延伸阅读"><a href="#参考-amp-延伸阅读" class="headerlink" title="参考&amp;延伸阅读"></a>参考&amp;延伸阅读</h2><ul>
<li><a href="http://blog.securem.eu/serverside/2015/08/25/setting-up-owncloud-server-in-a-docker-container/" target="_blank" rel="external">Setting up an ownCloud Server in a Docker container using Docker Compose</a></li>
<li><a href="https://github.com/vector090/vector090.github.io/wiki/%E4%BD%BF%E7%94%A8%E5%92%8C%E6%90%AD%E5%BB%BAownCloud%E7%A7%81%E6%9C%89%E4%BA%91%E8%A6%81%E7%82%B9" target="_blank" rel="external">使用和搭建ownCloud私有云要点</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章主要讲了为什么要搭建私有网盘，以及如何用 docker + ownCloud 搭建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前两天，360 云盘宣布将停止个人服务。一石激起千层浪，关于如何选择网盘，如何应对网盘关闭的讨论一下子又变得此起彼伏
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ownCloud" scheme="http://geekplux.com/tags/ownCloud/"/>
    
      <category term="docker" scheme="http://geekplux.com/tags/docker/"/>
    
      <category term="网盘" scheme="http://geekplux.com/tags/%E7%BD%91%E7%9B%98/"/>
    
      <category term="云" scheme="http://geekplux.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>如何阅读一篇学术论文</title>
    <link href="http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html"/>
    <id>http://geekplux.com/2016/05/31/how-to-read-a-research-paper.html</id>
    <published>2016-05-31T12:49:56.000Z</published>
    <updated>2016-11-02T10:18:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个<strong>知识过剩</strong>的时代。大量标榜为「干货」的文章每时每刻都在不断地产出，搜索引擎的便捷似乎也让我们离这些「知识」只有一步之遥。然而，随着多年在互联网上的浸淫，我发现<strong>越是容易得到的知识，价值越不大，留存的时间也越不长</strong>。所以，相对于那些东拼西凑组成的所谓干货，一本好书或一篇好的学术论文，才是知识的结晶（单从前后两者成文的时间上就可以很好的证明这点）。</p>
<p>关于「如何阅读一本书」的讨论，已经盈千累万，而关于「如何阅读一篇学术论文」的似乎还凤毛麟角。所以这篇文章我打算写一写我在阅读论文过程中总结出的一些方法，希望能对你有帮助，当然如果你有其他更好的方法，欢迎补充。文章共分为四个部分，第一部分介绍读论文的核心要素，第二部分列出阅读单篇论文的具体步骤，第三部分是一些补充。方法论讲完之后，最后一部分将阐述为什么要阅读文献期刊。</p>
<h2 id="一、阅读论文的核心要素"><a href="#一、阅读论文的核心要素" class="headerlink" title="一、阅读论文的核心要素"></a>一、阅读论文的核心要素</h2><p>根据每个人读论文的目的不同，阅读的侧重点也会有所不同，但都不外乎要获取知识、解决问题，所以无论你的目的是什么，有<strong>三个核心要素</strong>是你在阅读一篇论文时必须掌握的：</p>
<ol>
<li>这篇论文主要表达的是什么？作者的写这篇论文的目的是什么？或者说是这篇文章做出了什么成果？</li>
<li>这篇论文的观点/成果是如何实现的？作者用了哪些论据来支持他的观点/成果？</li>
<li>相关的工作有哪些？在这篇文章之前有什么已成立/取得的观点/成果？作者的观点/成果主要是建立在哪个的基础上？作者的观点/成果比别人突出在哪里？</li>
</ol>
<p>阅读论文不能盲目的去读，要<strong>带着问题去读</strong>才有收获，只要了解了这三个核心要素，就可以对论文有一个整体的印象。</p>
<a id="more"></a>
<h2 id="二、阅读论文的步骤"><a href="#二、阅读论文的步骤" class="headerlink" title="二、阅读论文的步骤"></a>二、阅读论文的步骤</h2><p>针对<strong>单篇</strong>论文：</p>
<ol>
<li><strong>认真</strong>地阅读标题、Abstract 和 Introduction。</li>
<li>把每一个章节的标题、子标题都过一遍，具体的内容先不急着看。</li>
<li>阅读 Conclusion，回应刚才的 Abstract 和 Introduction。</li>
<li>瞥一眼参考文献，看引用了哪些文章，里面有没有自己已经看过的。</li>
</ol>
<p>这四个步骤完毕之后，基本上可以解答上文提到的三个核心问题。而且你还能获得额外的一些信息，比如这篇文章和我研究的相关性、值不值得我精读、写的是否通俗易懂、我的知识储备是否能读等等。</p>
<p>如果得到的判断是这篇文章需要精读，那么我们可以开始下面的步骤：</p>
<ol>
<li>阅读文章的主体，重点注意抛出的观点，和提出的论据。</li>
<li>对于有公式、图表或其他具体论述的地方要多关注，时间足够就认真阅读。</li>
<li>遇到有引用参考文献的地方，先不要打断当前的阅读，但要在脑子里有个印象，以便将来进行相关的阅读，从而更好的理解本文的背景。</li>
</ol>
<p>这三个步骤花的时间可能是上面四个步骤时间的几倍，完成之后基本上对整篇文章的细节都掌握了。如果没有读懂，可能是自己的知识不够，也有可能是状态不好，你可以选择把这篇文章放在一边以后在读，或者再把这三个步骤重复几遍。当然，如果你读懂了，并且这篇文章的内容正是你苦寻已久的及时雨，那么可以进行下面这步：</p>
<ol>
<li>把文章的论证重现一遍。</li>
<li>改动重现过程中的相关步骤，与本文进行对比。</li>
</ol>
<p>完成这步，你对文章的理解程度肯定会比一般人深，如果有新的发现或结论，你还可以与原作者进行交流，或自己在其基础上发表新的论文等。</p>
<h2 id="三、一些补充"><a href="#三、一些补充" class="headerlink" title="三、一些补充"></a>三、一些补充</h2><p>上一节中的阅读步骤都是针对单篇论文的，其实在阅读论文过程中，我们很少是阅读完一篇再读下一篇，而通常是同时读几篇，每篇只读一部分，得到答案就够了。所以针对上述的步骤，还需要一些补充：</p>
<ol>
<li>要获取某个知识/解决方案时，应该是<strong>大规模、分批次</strong>阅读，而<strong>不是逐篇阅读</strong>（通常这篇读不懂的，会在另一篇中有答案）。</li>
<li>拿到一个方向相关的大量论文后，尽可能从标题判断出阅读顺序（也要考虑发表时间）。</li>
<li>阅读单篇论文，<strong>不要逐行阅读</strong>，提炼出适合自己的阅读论文顺序。</li>
<li>阅读论文时<strong>要敢于想象（猜）</strong>，大胆假设，小心验证，很可能一次性就猜对，节约很多时间。</li>
<li>每篇论文中详细的推导过程，很可能你根本不需要懂。</li>
<li>不要有公式恐惧症。关键的公式可能就三五个，其他不懂也没关系。公式之间的恒等式推导过程可以完全略。假如到了万不得已非要看懂的情况，重点看公式推导过程中引入的假设条件，和公式中每个字母所指代的东西。</li>
<li>读不懂的时候，不要气馁，可能是自己的知识储备还不够，也可能是今天的状态不好，先放一边，读下一篇。</li>
</ol>
<p>大量阅读提升广度，精准阅读提升深度。读的越多越熟练。</p>
<h2 id="四、为什么要阅读文献期刊"><a href="#四、为什么要阅读文献期刊" class="headerlink" title="四、为什么要阅读文献期刊"></a>四、为什么要阅读文献期刊</h2><p>只要深入掌握到阅读与分析期刊论文的技巧, 就可以掌握到可能在大学不曾研习过的三种能力:</p>
<ol>
<li>从无组织的知识中检索、筛选、组织知识的能力</li>
<li>对一切既有进行精确批判的独立自主判断能力</li>
<li>创造新知识的能力</li>
</ol>
<p>阅读论文是我在研一后半年才意识到的一件收益很大的事（惭愧），也是一个漫长的旅程。如果你也有幸开始这个旅程，希望你能轻松上路，如果你在途中遇到了困难，希望你能「不求甚解」，从万千论文中挑出自己最容易读懂的读，挑软柿子捏。等走的路多了，自然会知道哪有坑洼，哪有岔路。这些话也送给我自己。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Keshav, S. (2007). How to read a paper. ACM SIGCOMM Computer Communication Review, 1–3. <a href="http://doi.org/10.1145/1273445.1273458" target="_blank" rel="external">http://doi.org/10.1145/1273445.1273458</a></li>
<li>Laramee, R. S. (2011). How to read a visualization research paper: Extracting the essentials. IEEE Computer Graphics and Applications, 31(3), 78–82. <a href="http://doi.org/10.1109/MCG.2011.44" target="_blank" rel="external">http://doi.org/10.1109/MCG.2011.44</a></li>
<li>彭明辉《研究所新生完全求生手册》</li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个&lt;strong&gt;知识过剩&lt;/strong&gt;的时代。大量标榜为「干货」的文章每时每刻都在不断地产出，搜索引擎的便捷似乎也让我们离这些「知识」只有一步之遥。然而，随着多年在互联网上的浸淫，我发现&lt;strong&gt;越是容易得到的知识，价值越不大，留存的时间也越不长&lt;/strong&gt;。所以，相对于那些东拼西凑组成的所谓干货，一本好书或一篇好的学术论文，才是知识的结晶（单从前后两者成文的时间上就可以很好的证明这点）。&lt;/p&gt;
&lt;p&gt;关于「如何阅读一本书」的讨论，已经盈千累万，而关于「如何阅读一篇学术论文」的似乎还凤毛麟角。所以这篇文章我打算写一写我在阅读论文过程中总结出的一些方法，希望能对你有帮助，当然如果你有其他更好的方法，欢迎补充。文章共分为四个部分，第一部分介绍读论文的核心要素，第二部分列出阅读单篇论文的具体步骤，第三部分是一些补充。方法论讲完之后，最后一部分将阐述为什么要阅读文献期刊。&lt;/p&gt;
&lt;h2 id=&quot;一、阅读论文的核心要素&quot;&gt;&lt;a href=&quot;#一、阅读论文的核心要素&quot; class=&quot;headerlink&quot; title=&quot;一、阅读论文的核心要素&quot;&gt;&lt;/a&gt;一、阅读论文的核心要素&lt;/h2&gt;&lt;p&gt;根据每个人读论文的目的不同，阅读的侧重点也会有所不同，但都不外乎要获取知识、解决问题，所以无论你的目的是什么，有&lt;strong&gt;三个核心要素&lt;/strong&gt;是你在阅读一篇论文时必须掌握的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这篇论文主要表达的是什么？作者的写这篇论文的目的是什么？或者说是这篇文章做出了什么成果？&lt;/li&gt;
&lt;li&gt;这篇论文的观点/成果是如何实现的？作者用了哪些论据来支持他的观点/成果？&lt;/li&gt;
&lt;li&gt;相关的工作有哪些？在这篇文章之前有什么已成立/取得的观点/成果？作者的观点/成果主要是建立在哪个的基础上？作者的观点/成果比别人突出在哪里？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;阅读论文不能盲目的去读，要&lt;strong&gt;带着问题去读&lt;/strong&gt;才有收获，只要了解了这三个核心要素，就可以对论文有一个整体的印象。&lt;/p&gt;
    
    </summary>
    
      <category term="Research" scheme="http://geekplux.com/categories/Research/"/>
    
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
      <category term="方法论" scheme="http://geekplux.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="Research" scheme="http://geekplux.com/tags/Research/"/>
    
  </entry>
  
  <entry>
    <title>毕业后的两年</title>
    <link href="http://geekplux.com/2016/02/15/two-years-after-graduated.html"/>
    <id>http://geekplux.com/2016/02/15/two-years-after-graduated.html</id>
    <published>2016-02-15T15:03:27.000Z</published>
    <updated>2016-02-15T17:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=16504268&auto=0&height=66"></iframe>

<p>在我们 5 岁的时候，过一年相当于经历人生的 1/5，而到了 25 岁的时候，过一年却相当于只经历了人生的 1/25。时间的重要性似乎随着我们年龄的增长而变得越来越低。主观感受上我们觉得时间走的越来越快了，而实际上却是我们对时空的认知变得扭曲了。</p>
<p>所以我们需要不断整理、回顾自己的人生，就像偶尔给自己留张自拍一样，说不定哪一天就忘记自己当时长什么样了。</p>
<p>距离我上次大学毕业总结（<a href="http://geekplux.com/2014/02/02/goodbye_my_university.html">Goodbye，我的大学</a>）已经过去了两年。都说 20-25 岁的年纪是人生最不怕折腾的年纪，如今我躺在床上，闭眼回想自己这过去的两年，满是<strong>任性</strong>。</p>
<p><em>本文和上次总结不同，将以时（liu）间（shui）线（zhang）的方式来叙述。两年的经历可以分为六个部分，其中五和六两个部分属于持续经历，七是一些胡思乱想。如果你觉得废话太多，可以只看<strong>黑体字</strong>部分或最后的总结。</em></p>
<h2 id="一、初到上海"><a href="#一、初到上海" class="headerlink" title="一、初到上海"></a>一、初到上海</h2><p>这完全是一次没有计划，说走就走的求职之路，当时的我还没意识到「<strong>大学毕业后的第一份工作至关重要</strong>」这一点。</p>
<a id="more"></a>
<h3 id="只呆了一个月的公司"><a href="#只呆了一个月的公司" class="headerlink" title="只呆了一个月的公司"></a>只呆了一个月的公司</h3><p>第一家公司我只呆了一个月。由于是靠朋友关系硬塞进去的，所以我在其中的一个月没有任务，也没有要求，扮演着一个无所事事的角色。天天看 PHP 手册的工作让我很没有成就感，加之公司氛围不怎么好，我很快决定另投简历。</p>
<p><strong>人只有写简历的时候才会觉得自己有多么乏善可陈</strong>。虽然我在大学期间也实习过，但真正想找一份程序员的工作只能靠我仅有的毕设经验（一款 Android APP）。在收到的回应中，其中一个创业团队和我一见钟情。</p>
<p>在这过程中，我要感谢昊哥对我无微不至的照顾，同时也有不少感触：</p>
<ul>
<li><strong>如果对一个环境不满意，而你又改变不了它，直接走</strong>（我真的不是在影射什么）。</li>
<li><strong>简历要在日常积累，而投简历的时候要明确目标</strong>。</li>
<li><strong>自己找到的工作比靠介绍进去的要有成就感的多</strong>。</li>
</ul>
<h3 id="创业艰辛"><a href="#创业艰辛" class="headerlink" title="创业艰辛"></a>创业艰辛</h3><p>辗转来到这家创业公司<a href="http://10years.me" target="_blank" rel="external">十年后</a>。本来我以为我是来作 Android 程序员的，结果第二天 CEO 就和我说：「Android 客户端还有点遥远，不如你来作 Web 前端吧」……从此我走上了这条坑多无比的不归路。</p>
<p>在十年后期间，我最大的感受是创业真的很难。<strong>创业靠的不是独一无二的 Idea，而是团队和决策</strong>。同样的创意，可能展现出来的产品形态完全不同；即使产品思路相同，决策不同也可能导致发展背道而驰；即使决策相同，不同的团队执行起来也是风格迥异。然而，就算思路绝对正确，执行一流，最终也会因为各种各样的问题（有的问题小到不起眼）而中道崩殂。遥想当年 InnoSpace 里那么多的创业团队现在还剩多少。</p>
<p><strong>创业的日子没有那么多快意恩仇，更多的是柴米油盐</strong>。加入一家创业公司，有幸经历这些，让我觉得很幸运。不仅如此，在十年后的日子，也是我走出校门以来最开心的日子。</p>
<h4 id="重要的不是做什么，而是和什么人在一起"><a href="#重要的不是做什么，而是和什么人在一起" class="headerlink" title="重要的不是做什么，而是和什么人在一起"></a>重要的不是做什么，而是和什么人在一起</h4><p>十年后团队里最开始青一色的复旦人，复旦兼容并包却又与众不同的气质在他们身上体现的淋漓尽致。桉哥和冬神可能是我见过最理想化的人了，总给我一种遗世孤立的感觉，和他俩呆在一起的时间最长，受他俩影响最大。此时我才真正理解了为什么毕业后第一份至关重要，因为<strong>我们在象牙塔里对社会没有直观的感受，而抛开乐趣、价值、薪水不谈，第一份工作恰恰帮助初出茅庐的你构建了一个社会认知的雏形，间接的还可能影响你的三观</strong>。以下是我在那段时间感悟到的：</p>
<h4 id="心灵开放"><a href="#心灵开放" class="headerlink" title="心灵开放"></a>心灵开放</h4><p>心态开放我暂且只认识到两点：</p>
<ul>
<li><strong>不设限</strong></li>
<li><strong>不贴标签</strong></li>
</ul>
<p>我们总是在无形之中给自己套上枷锁，事实上<strong>人总比自己想象的更加自由</strong>。生活一成不变的原因大多是因为我们没有打破局限的意识。<strong>不断的尝试新事物，尝试以前不敢做的事才能突破自己</strong>。感谢他们让我认识到这一点，因为他们似乎无所不能。不管我做什么他们都没有黑我嘲笑我，反而是不断的支持与鼓励，这不是表面上的，因为他骨子里都是这种「玩世不恭」的人。</p>
<p>我们也不应给事物设限，<strong>不要因为一点而否定全局</strong>。也<strong>不要给任何人或事物贴标签</strong>，不知道为什么我们在日常生活中特别喜欢贴标签，比如北方人都特别耐寒，南方人都是蛮夷等等。<strong>大多数标签都是针对特定个体在特定环境下的描述，所以抛开影响因子来下定论完全是耍流氓</strong>。事物和人一样，不是一成不变的，也都是多元的，你可以接受他和你共鸣的地方，而忽视其他。</p>
<h4 id="慢即是快"><a href="#慢即是快" class="headerlink" title="慢即是快"></a>慢即是快</h4><p>快节奏社会里很多人都是「急功近利」的，看本书都追求「快速阅读」，我当时也是。但后来我渐渐意识到这有点本末倒置，<strong>持之以恒</strong>才是最重要的。这是我在学习 <a href="http://geekplux.com/2015/01/05/play-ukulele.html">Ukulele</a> 的过程中悟到的。每天弹10分钟，比一天弹几个小时却停练一周要进步快的多。其他事也是这样，<strong>可能你现在看不到任何收益，但只要坚持，总会有量变达到质变的一天</strong>。爱因斯坦都说复利是世界第八大奇迹。</p>
<p>同时，单纯的享受过程也是很有趣的事，就拿读书来说，很多书是不能囫囵吞枣的，你得细嚼慢咽才能吃透它的内容。而且，每天坚持看几页，一年下来也能看不少书。我们不应论量，而应论质。</p>
<h2 id="二、考研岁月"><a href="#二、考研岁月" class="headerlink" title="二、考研岁月"></a>二、考研岁月</h2><p>参加完毕业典礼后，我鬼使神差地萌生了考研的想法，原因有很多，但其实最大的理由只是因为我想体验一下考研是什么样子的。于是，辞职，回家复习。</p>
<p><strong>考研备考可能是我一生中最孤独的日子了</strong>。虽然和高考一样都是朝着一个确切的目标奋斗，但是高考有同学、有老师、有家长，而考研你什么都没有，甚至连复习计划都得自己定，有的只是万一考不上的压力和对考上之后日子的幻想。那时候我坐在自习室里，偶尔会怀疑自己是不是回到了高中，耳畔响起罗大佑的《闪亮的日子》、张雨生的《永远不回头》和赵雷的《我们的时光》等等，然后若有所思的看看窗外。</p>
<p><strong>考研除了孤独，还是脆弱的</strong>。我要感谢毛哥在考研整个复习阶段孜孜不倦鼓励。尤其在最后的阶段，一个小题不会做都可能是悲愤的导火索。每当没有信心的时候，毛哥就会如永动机一样开始鼓励我，这帮我挺过了那最艰苦的岁月。不过不幸的是，<strong>考研有可能和单恋一样，感动的是自己</strong>。</p>
<p>Anyway，<strong>考研的日子是宝贵的，是在这浮躁社会中难有的清静，是聆听内心独白的契机</strong>，坚持下来更是战胜自己的喜悦。最有趣的是，我 Wunderlist 上曾有一个长长的清单，上面写满了那些「等我考完以后」才能做的事，每次看看都会笑。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/2016-02-15%20221528.jpg" alt="自习室"></p>
<h2 id="三、又至上海"><a href="#三、又至上海" class="headerlink" title="三、又至上海"></a>三、又至上海</h2><p>考研的结果是我没有考上华科，无奈之下来沪调剂，结果又因为本科出身太差被各种拒绝，那段时间也是有些心灰意冷，遂决定找工作。其中印象最深的是第一场面试：去饿了么被 <a href="https://github.com/sofish" target="_blank" rel="external">sofish</a> 面试。</p>
<p>半年没写代码的我压根没有准备就去了（我也不知我何来的自信），一答不上来头上就直冒汗。然而 sofish 没有怪我浪费他时间，反而循循善诱，不停的教我如何更加深入的学习前端技术，超级 Nice! 虽然最后被刷，但我仍然很感激这次面试，让我学会了很多。</p>
<p>最终我又选了一家创业公司——一财新媒体。不到半年的时间，从最初的技术团队只有几个人到后来的几十个人，我也算是经历了公司成长最快的一段时期。有趣的是，当时我不仅要写代码，还要负责面试的工作，虽然当时我很不喜欢，但现在看来很有意义的一段经历，至少<strong>让我从面试官的角度体会到了哪些品质、技能是一个合格程序员所必须具备的</strong>。</p>
<p>在一财的日子，可能是<strong>我毕业以来最像「上班」的一段日子</strong>。第一次把自己当作一名职员来看待，第一次体会到上下级，第一次体会到各司其职互相配合的感觉。。。在职场方面我是稚嫩的，幸亏有我可爱的上司经常教我各种人生经验。还有我司各种卖（men）萌（sao）的同事，跟你们互黑真的是非常愉快。</p>
<h2 id="四、杭州的象牙塔"><a href="#四、杭州的象牙塔" class="headerlink" title="四、杭州的象牙塔"></a>四、杭州的象牙塔</h2><p>尽管直到最后辞职，所有人可能都没理解为什么我要去杭师大读研（调剂成功），但我还是毅然决然的去了。</p>
<p>每次做一些重大决定前，<strong>我们其实内心早就有了选择，所谓的分析，调研，到底哪个选项好，其实都是为了印证、迎合自己内心的想法</strong>。每次询问别人的意见，其实只是想让别人认同自己<strong>既定</strong>的想法。</p>
<p>从职场回到校园，很多地方都不适应，尤其是<strong>心态很难转变</strong>。本来是每天都有任务要完成，现在变成了自己给自己找任务；本来每天面对的是实际的业务；现在变成了自己猜测出来的需求，本来每天是按时上班，主动付出，现在变成了每天上课，被动接受。。。我怀疑我到现在都没有彻底转换过来。不过<strong>工作后再读研比大学毕业直接读研有个优势，那就是我知道我要学的是什么</strong>。</p>
<p><strong>读研和本科也有所不同</strong>。研究生更多的是自己找一个问题，运用所学自己去研究，大学则还不理解什么是研究。读论文可能是研究生最常做的事，每每读起一篇优秀的论文，总能深切的体会到什么是「站在巨人的肩膀上」。此外，研究生需要天天呆在实验室，不过好在我大学里就天天泡在实验室，所以对这种实验室-宿舍两点一线的生活没有一丝不适。</p>
<p>然而，由于我总能给自己的偷懒找到恰当的理由，所以<strong>在学校的紧张程度和努力程度远没有工作时的大</strong>。偶尔去西湖浪一浪，美其名曰释放压力。</p>
<h2 id="五、自由职业与外包"><a href="#五、自由职业与外包" class="headerlink" title="五、自由职业与外包"></a>五、自由职业与外包</h2><p>编程也算是一种创造性工作了，自由职业一直是我向往的，外包只是偶尔开开荤。</p>
<p>人生第一个外包来的特别突然，对方提到的技术对于当时的我来说完全不会，但我还是一口答应了下来（毕竟 too young）。Deadline 之前的那一个通宵，可能是我技术提升最快的一夜。虽然这个网页最终还是没令对方满意，但我还是学到了不少前端技术，也深深体会了「不逼自己一把，不知道自己有多优秀」这句话。后来的几个小外包经历，也慢慢让我有了<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODk1MjgwMQ==&amp;mid=400071755&amp;idx=1&amp;sn=f086671ea081b96b7f1268867b38715c#rd" target="_blank" rel="external">盲目的自信</a>。</p>
<p>不过外包归根结底还是有点苦，接过的都冷暖自知。而且<strong>外包过来过去都是没有挑战性的体力活，很难在技术上有所成长</strong>。相对来说，如果有一个稳定的远程工作会好很多，技术会随着业务的增长而增长。</p>
<p>另外我要提一下，从第一份外包到后来的一些机会大多是通过我博客来找到我的，<strong>所以写博客是一件收益巨大的事</strong>，尤其是写<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">优秀的博客</a>。</p>
<h2 id="六、公众号"><a href="#六、公众号" class="headerlink" title="六、公众号"></a>六、公众号</h2><p>运营一个公众号两年半的感想大多都写在了<a href="http://mp.weixin.qq.com/s?__biz=MjM5Mjg0NjMwMQ==&amp;mid=400413023&amp;idx=1&amp;sn=84d3e6670c6aaa4dcaca756b778b25a4#rd" target="_blank" rel="external">晓然，回归</a>里，当时主要说了说心态要平和，但还有一些想在这里絮叨絮叨：</p>
<h3 id="弱关系"><a href="#弱关系" class="headerlink" title="弱关系"></a>弱关系</h3><p>弱关系很重要，因为弱关系可以提供一些「圈外」的信息。而维持弱关系的关键，不在于竭尽所能讨好别人，也不在于想法设法不得罪人，而在于<strong>不断提升自己的价值</strong>。</p>
<h3 id="沉默是金"><a href="#沉默是金" class="headerlink" title="沉默是金"></a>沉默是金</h3><p>三种时候应该沉默：</p>
<ul>
<li>世上 99.9% 事与自己无关，<strong>不要随意发表评论</strong>。</li>
<li><strong>不要好为人师</strong>，总想给别人传授人生经验。</li>
<li>面对诽谤、质疑或者任何让你不爽的言论，<strong>不作回应</strong>是最好的处理方式。</li>
</ul>
<h2 id="七、一些胡思乱想"><a href="#七、一些胡思乱想" class="headerlink" title="七、一些胡思乱想"></a>七、一些胡思乱想</h2><h4 id="不反智"><a href="#不反智" class="headerlink" title="不反智"></a>不反智</h4><p>以我个人的浅见，我觉得反智可能是因为现在社会的价值观单一造成的。以下情况或多或少的出现在身边：</p>
<ul>
<li><strong>结果比过程更重要，文凭比学习的过程更重要</strong></li>
<li><strong>追求知识被认为无用，认真的行为被认为装逼</strong></li>
<li><strong>充满偏见，不想进一步学习，也抑制你学习的冲动</strong></li>
</ul>
<p>我这里不是批判反智的人，<strong>反智的定义很大，而且反智不含褒贬之意</strong>，我只是想要求自己在大多数情况下做到不反智，比如<strong>尊重版权</strong>。我很纳闷为什么有的人会抄的理直气壮，还反过来问我知识是不是应该共享。我觉得知识是应该共享，但更应该尊重创造这些知识的人。</p>
<h3 id="主观"><a href="#主观" class="headerlink" title="主观"></a>主观</h3><p><strong>每个人到底生活于何样的世界，首先取决于这个人对这个世界的理解</strong>。所有的一切，或所谓的现实，都可以分成两个部分：主体和客体。<strong>面对完全一样的客体时，不同的主体意味着所构成的现实完全不同</strong>。</p>
<p>有兴趣可以看看我之前写的一篇关于主观认知的文章——<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODk1MjgwMQ==&amp;mid=400800239&amp;idx=1&amp;sn=938f2a6307aef3b87d01b089496ecc47#rd" target="_blank" rel="external">假如我们的主观意识都是别人操控的</a>。</p>
<p>以上只是我这两年的一些胡思乱想，很多时候我自己也是糊涂的，不过总得有个标准以便偶尔跳脱出来审（si）视（kao）自（ren）己（sheng）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>人是群居动物，环境对人的影响至关重要。不到两年时间，我辗转了几个地方，其中对我影响最大的是在十年后工作的日子，而我最专注、最不浮躁、最无聊的时光是考研的那段，其他的经历好像也都蛮不错，总之是没什么后悔和遗憾。</p>
<p>我做很多事之前都没什么确切的理由，想做便去做了，其实挺任性的。但人生只是个过程，如果日复一日的过着同样的生活真的很无趣。悟已往之不谏，知来者之可追，希望自己在新的一年中能体会更多样的<strong>平凡的人生</strong>吧。最后用一句话来结尾：</p>
<blockquote>
<p>「我还年轻，我渴望上路。带着最初的激情，追寻着最初的梦想，感受着最初的体验，我们上路吧 。」<br>——凯鲁亚克</p>
</blockquote>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;http://music.163.com/outchain/player?type=2&amp;id=16504268&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;在我们 5 岁的时候，过一年相当于经历人生的 1/5，而到了 25 岁的时候，过一年却相当于只经历了人生的 1/25。时间的重要性似乎随着我们年龄的增长而变得越来越低。主观感受上我们觉得时间走的越来越快了，而实际上却是我们对时空的认知变得扭曲了。&lt;/p&gt;
&lt;p&gt;所以我们需要不断整理、回顾自己的人生，就像偶尔给自己留张自拍一样，说不定哪一天就忘记自己当时长什么样了。&lt;/p&gt;
&lt;p&gt;距离我上次大学毕业总结（&lt;a href=&quot;http://geekplux.com/2014/02/02/goodbye_my_university.html&quot;&gt;Goodbye，我的大学&lt;/a&gt;）已经过去了两年。都说 20-25 岁的年纪是人生最不怕折腾的年纪，如今我躺在床上，闭眼回想自己这过去的两年，满是&lt;strong&gt;任性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文和上次总结不同，将以时（liu）间（shui）线（zhang）的方式来叙述。两年的经历可以分为六个部分，其中五和六两个部分属于持续经历，七是一些胡思乱想。如果你觉得废话太多，可以只看&lt;strong&gt;黑体字&lt;/strong&gt;部分或最后的总结。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、初到上海&quot;&gt;&lt;a href=&quot;#一、初到上海&quot; class=&quot;headerlink&quot; title=&quot;一、初到上海&quot;&gt;&lt;/a&gt;一、初到上海&lt;/h2&gt;&lt;p&gt;这完全是一次没有计划，说走就走的求职之路，当时的我还没意识到「&lt;strong&gt;大学毕业后的第一份工作至关重要&lt;/strong&gt;」这一点。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="总结" scheme="http://geekplux.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="Summary" scheme="http://geekplux.com/tags/Summary/"/>
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="Life" scheme="http://geekplux.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>建立索引式的学习方法</title>
    <link href="http://geekplux.com/2015/12/08/learning-by-index.html"/>
    <id>http://geekplux.com/2015/12/08/learning-by-index.html</id>
    <published>2015-12-08T13:53:27.000Z</published>
    <updated>2016-02-03T07:52:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法的重要性不必多言，相信每个人都知道。然而，并不是掌握了好的学习方法，就可以让你事半功倍，而是要找到适合自己的学习方法。<strong>索引式</strong>的学习方法就很适合我。</p>
<h2 id="何为索引式的学习方法"><a href="#何为索引式的学习方法" class="headerlink" title="何为索引式的学习方法"></a>何为索引式的学习方法</h2><p>索引式的学习方法是我自己起的名字，我不知道在别人那里叫什么。其要义是指<strong>在学习一项技能时，先不深究其细节，而是建立索引</strong>。这就像看书时先看目录一样，把目录多看几遍，对整本书的结构有所了解之后，再去看自己想看的章节。</p>
<h2 id="为什么要建立索引式的学习方法"><a href="#为什么要建立索引式的学习方法" class="headerlink" title="为什么要建立索引式的学习方法"></a>为什么要建立索引式的学习方法</h2><h3 id="迅速建立知识框架"><a href="#迅速建立知识框架" class="headerlink" title="迅速建立知识框架"></a>迅速建立知识框架</h3><p>循序渐进，步步为营的学习方法已经不适合现在的节奏了。这我在上次的文章《入门为什么这么难》里已经提到过：<strong>掌握一项技能要迅速掌握其主干，其余的细枝末节都不去管</strong>。</p>
<p>学习一项技能时，你不能保证你目前所在学的东西将来会用到。就算用到，也可能没有你现在所探究的这么深入。那么我们<strong>只需要知道有这个东西，在脑中建立这部分知识的索引，等用到他的时候再去查阅资料重新学习就好</strong>。</p>
<a id="more"></a>
<h3 id="专注突破，实践巩固"><a href="#专注突破，实践巩固" class="headerlink" title="专注突破，实践巩固"></a>专注突破，实践巩固</h3><p>建立索引之后，其他部分的知识可以暂时地抛诸脑后，而把<strong>精力专注在当前的节点</strong>，「集中优势兵力迅速突破」。</p>
<p>表面上，因其不究细节，索引式的学习方法仿佛对知识的了解都浮于表面。但事实上，对于当前在学的、要用的它都力求扎实掌握，熟练运用。</p>
<p>不仅如此，因为索引式的学习方法强调<strong>用时才学</strong>，这就保证你现在要学的，肯定是你即将要用到的。学完之后马上运用，相当于二次学习。<strong>实践会加深对知识的理解</strong>，就像中学时做题是概念的补充一样。</p>
<h2 id="建立索引的核心方法"><a href="#建立索引的核心方法" class="headerlink" title="建立索引的核心方法"></a>建立索引的核心方法</h2><p>如何建立索引？首先要了解怎么样才算真正的把索引建立成功。</p>
<p>建立成功索引的标准是你在<strong>遇到问题时能立马浮现出这是在运用哪一块的知识</strong>。比如需要抠图的时候，应该运用Photoshop的快速选择工具，需要去除水印的时候，应该运用Photoshop的仿制图章工具或者修补工具等等。</p>
<p>所以建立索引的核心方法是<strong>要了解该技能（软件、工具）每一处知识点（功能）的用处是什么</strong>。它能解决什么问题，遇到什么问题的时候需要用到这块的知识。</p>
<p>如果教材里没说，自己也看不懂，就记下这个名词，或者该章节提到的一些关键字。以便<strong>将来搜索时知道用什么关键字去搜，或者搜索结果中提到的关键字能让你联想到是在用哪部分的知识</strong>。</p>
<p>建立索引的方式不拘一格，可以按照知识点去建，也可以按照用途、方向来建，亦或按照学习目的去建，随你喜欢。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>听过那么多的道理，依然过不好一生。见过这么多的学习方法，依旧学不好。索引式的学习方法适合那种学得快忘得也快的人，所以自己多琢磨琢磨，针对自己特点总结出一套方法论才是最好的。尽量提升效益，而不是增加成本。个人愚见，请多指点。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习方法的重要性不必多言，相信每个人都知道。然而，并不是掌握了好的学习方法，就可以让你事半功倍，而是要找到适合自己的学习方法。&lt;strong&gt;索引式&lt;/strong&gt;的学习方法就很适合我。&lt;/p&gt;
&lt;h2 id=&quot;何为索引式的学习方法&quot;&gt;&lt;a href=&quot;#何为索引式的学习方法&quot; class=&quot;headerlink&quot; title=&quot;何为索引式的学习方法&quot;&gt;&lt;/a&gt;何为索引式的学习方法&lt;/h2&gt;&lt;p&gt;索引式的学习方法是我自己起的名字，我不知道在别人那里叫什么。其要义是指&lt;strong&gt;在学习一项技能时，先不深究其细节，而是建立索引&lt;/strong&gt;。这就像看书时先看目录一样，把目录多看几遍，对整本书的结构有所了解之后，再去看自己想看的章节。&lt;/p&gt;
&lt;h2 id=&quot;为什么要建立索引式的学习方法&quot;&gt;&lt;a href=&quot;#为什么要建立索引式的学习方法&quot; class=&quot;headerlink&quot; title=&quot;为什么要建立索引式的学习方法&quot;&gt;&lt;/a&gt;为什么要建立索引式的学习方法&lt;/h2&gt;&lt;h3 id=&quot;迅速建立知识框架&quot;&gt;&lt;a href=&quot;#迅速建立知识框架&quot; class=&quot;headerlink&quot; title=&quot;迅速建立知识框架&quot;&gt;&lt;/a&gt;迅速建立知识框架&lt;/h3&gt;&lt;p&gt;循序渐进，步步为营的学习方法已经不适合现在的节奏了。这我在上次的文章《入门为什么这么难》里已经提到过：&lt;strong&gt;掌握一项技能要迅速掌握其主干，其余的细枝末节都不去管&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;学习一项技能时，你不能保证你目前所在学的东西将来会用到。就算用到，也可能没有你现在所探究的这么深入。那么我们&lt;strong&gt;只需要知道有这个东西，在脑中建立这部分知识的索引，等用到他的时候再去查阅资料重新学习就好&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="学习" scheme="http://geekplux.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Learning" scheme="http://geekplux.com/tags/Learning/"/>
    
      <category term="方法论" scheme="http://geekplux.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>为什么我喜欢写代码</title>
    <link href="http://geekplux.com/2015/11/13/why-i-like-coding.html"/>
    <id>http://geekplux.com/2015/11/13/why-i-like-coding.html</id>
    <published>2015-11-13T15:04:22.000Z</published>
    <updated>2016-11-02T10:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我知道很大一部分的程序员，最初都是游戏爱好者。因为喜欢游戏，进而喜欢电脑，研究它，想知道怎么制作个游戏，怎么破解一个游戏等等。这部分因为喜欢一件事进而喜欢上鼓捣代码的人，算作一类。另一类就是我这种，一开始并不知道自己真正喜欢的是什么，甚至不知道什么是代码，但接触了编程之后，就停不下来的人。</p>
<p>虽然我在高考填志愿的时候，专业一栏都写的是「计算机科学与技术」，但我对这个专业的了解比对女性生理结构的了解还少。大一的课程终于接触到了真正的代码，我却没有因此产生浓厚的兴趣。而后来，当运行成功一个自己编写的程序时，那种头皮发麻，一股电流从背脊击穿头部的感觉，让我瞬间明白了这才是我该做一辈子的事。</p>
<h2 id="编程的反馈很快"><a href="#编程的反馈很快" class="headerlink" title="编程的反馈很快"></a>编程的反馈很快</h2><p>编程之所以有趣，最主要的原因是它能即时反馈。你写下一行代码，立即就能知道它的对错；你写完一个程序，一运行就能知道成功与否；如果做的是界面，那就更明显了，代码一变，界面立马就变。</p>
<p>所以编程学起来也特别快，它能给你立马呈现出你这两个小时到底学到了什么。成就感的积攒，又会推动你进行下一步的学习，不停迭代。</p>
<p>人总是喜欢能更快得到回报的东西。</p>
<h2 id="痛并快乐着"><a href="#痛并快乐着" class="headerlink" title="痛并快乐着"></a>痛并快乐着</h2><a id="more"></a>
<p>众所周知，程序员最讨厌八阿哥（Bug)。除非是当天任督二脉被打通，一般情况下程序员写出的代码都会有Bug。有时候找Bug找的真的想撞墙，人都快崩溃了。我至今忘不了当初我上司，每次点击运行之后，大喊一声「决战吧，代码！」的样子。</p>
<p>但只要Bug一被解决，整个人都会「羽化而登仙」。。。被摧残过后的成果最令人兴奋。（不过我在这里友情提醒各位，如果你看到一个程序员眉头紧锁，千万不要去打扰他，不要问我为什么）</p>
<h2 id="编程很实用，且容易出作品"><a href="#编程很实用，且容易出作品" class="headerlink" title="编程很实用，且容易出作品"></a>编程很实用，且容易出作品</h2><p>好的程序员「笔落惊风雨,诗成泣鬼神」，分分钟能做出一个优秀的网站、APP 或实用的小工具。虽然说要做出颠覆世界或者能给自己带来巨额财富的软件很难，但做一个普通的小程序还是没问题的。比如我有个学长，特别喜欢写那种抢秒杀的代码，双十一前后抢到了一部 iPhone 6S 和各种免单。。。</p>
<h2 id="代码改变思维"><a href="#代码改变思维" class="headerlink" title="代码改变思维"></a>代码改变思维</h2><p>Code change the world 这句我一直知道，但代码改变思维我是真切体会到的。尤其是你学的编程语言或者框架多了之后，你的思维会被这些代码所影响。不知不觉，我们的思维方式可能从发散思维，变成了线性思维，或是面对不同的问题采用不同的思维方式。</p>
<p>一切的学科学到最后都是哲学，代码也是有哲学的。它渗透在我们的血液里，给我们渲染出了新的视野。很多程序猿在从业多年之后还保持着强大的好奇心，卓越的学习能力，开阔的眼界，这一定程度上能归功于代码。</p>
<p>虽然现在很多人鼓吹互联网泡沫就要破灭，但我觉得代码仍会是在未来生存必备的技能。美帝宣传「人人都应学编程」不是一句空话。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我知道很大一部分的程序员，最初都是游戏爱好者。因为喜欢游戏，进而喜欢电脑，研究它，想知道怎么制作个游戏，怎么破解一个游戏等等。这部分因为喜欢一件事进而喜欢上鼓捣代码的人，算作一类。另一类就是我这种，一开始并不知道自己真正喜欢的是什么，甚至不知道什么是代码，但接触了编程之后，就停不下来的人。&lt;/p&gt;
&lt;p&gt;虽然我在高考填志愿的时候，专业一栏都写的是「计算机科学与技术」，但我对这个专业的了解比对女性生理结构的了解还少。大一的课程终于接触到了真正的代码，我却没有因此产生浓厚的兴趣。而后来，当运行成功一个自己编写的程序时，那种头皮发麻，一股电流从背脊击穿头部的感觉，让我瞬间明白了这才是我该做一辈子的事。&lt;/p&gt;
&lt;h2 id=&quot;编程的反馈很快&quot;&gt;&lt;a href=&quot;#编程的反馈很快&quot; class=&quot;headerlink&quot; title=&quot;编程的反馈很快&quot;&gt;&lt;/a&gt;编程的反馈很快&lt;/h2&gt;&lt;p&gt;编程之所以有趣，最主要的原因是它能即时反馈。你写下一行代码，立即就能知道它的对错；你写完一个程序，一运行就能知道成功与否；如果做的是界面，那就更明显了，代码一变，界面立马就变。&lt;/p&gt;
&lt;p&gt;所以编程学起来也特别快，它能给你立马呈现出你这两个小时到底学到了什么。成就感的积攒，又会推动你进行下一步的学习，不停迭代。&lt;/p&gt;
&lt;p&gt;人总是喜欢能更快得到回报的东西。&lt;/p&gt;
&lt;h2 id=&quot;痛并快乐着&quot;&gt;&lt;a href=&quot;#痛并快乐着&quot; class=&quot;headerlink&quot; title=&quot;痛并快乐着&quot;&gt;&lt;/a&gt;痛并快乐着&lt;/h2&gt;
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="感想" scheme="http://geekplux.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="情感" scheme="http://geekplux.com/tags/%E6%83%85%E6%84%9F/"/>
    
      <category term="代码" scheme="http://geekplux.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>写文章的小技巧</title>
    <link href="http://geekplux.com/2015/10/28/writing-skills.html"/>
    <id>http://geekplux.com/2015/10/28/writing-skills.html</id>
    <published>2015-10-28T10:24:11.000Z</published>
    <updated>2017-02-22T16:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>既然是小技巧，那么就不敢班门弄斧，只简单说说自己平时遵循的几条写作原则：</p>
<h2 id="尽量用短句"><a href="#尽量用短句" class="headerlink" title="尽量用短句"></a>尽量用短句</h2><ul>
<li>写作以表达清晰为首要宗旨，所以 <strong>尽量用短句</strong> 。长句会增加理解成本，尤其是对于中文来说。中文的定语是放在被修饰词前面的，不像英语通常放在后面，用从句很容易扩展。中文你要用从句，还 <strong>不如直接另起一句话</strong> 。</li>
</ul>
<p>而且能一句话说清楚的，不要绕来绕去解释。</p>
<ul>
<li>在句语句之间 <strong>多用连接词</strong> ，一方面表明其联系，一方面增强连贯性。</li>
<li><strong>不要用晦涩难懂的词</strong> 。我们不是在写高考作文。</li>
<li><strong>对标点的使用要尽量规范。</strong> 尽量少用感叹号。</li>
</ul>
<h2 id="文章逻辑要清晰"><a href="#文章逻辑要清晰" class="headerlink" title="文章逻辑要清晰"></a>文章逻辑要清晰</h2><h3 id="分段、分点说明"><a href="#分段、分点说明" class="headerlink" title="分段、分点说明"></a>分段、分点说明</h3><p>众所周知，我们现在看到长篇大论的文章都难以下咽。但如果在文中加几个段落标题，效果就大大不同。<br>同样的，在遇到排列句的时候，每句单独成行，比一整段要清晰的多。</p>
<p>这些措施一方面是在排版上进行改进，提升了阅读体验。更重要的一方面是这样使你的文章逻辑更加清晰。<br><strong>写文章和做数学证明题一模一样。每一段都证明一个小问题，下一段的证明，依赖于上一段的结论。</strong> 所以每段有个主题，就比胡乱写强很多。</p>
<a id="more"></a>
<h3 id="要有重点"><a href="#要有重点" class="headerlink" title="要有重点"></a>要有重点</h3><p>无论说话还是写作，都最忌没有重点。如果读完一篇文章，你不知道这篇文章的主旨是什么；读完一段话，你不知道这段话是在讲什么。那这篇文章就太失败了。<br>用粗体把重点标注出来，很容易吸引眼球。</p>
<h2 id="随时记录"><a href="#随时记录" class="headerlink" title="随时记录"></a>随时记录</h2><p>想题目恐怕是世界上最难的事情了。其实日常生活中，很多时刻会有想写的冲动。尤其是发呆的时候，脑子里估计都写了一大段了，但一被打断，又忘得一干二净。等真正要写文章的时候，只能拔剑四顾心茫然。<br>所以我们 <strong>平时一旦有点小思路，就拿手机记下来</strong> 。反正手机不离身，记东西很方便。不用记太细，记些关键字也行，整个过程耗时不会超过一分钟。</p>
<h2 id="立即动笔（键盘）"><a href="#立即动笔（键盘）" class="headerlink" title="立即动笔（键盘）"></a>立即动笔（键盘）</h2><p>题目定好以后，很多人会觉得，自己才想好了文章的前两点，后面都不知道怎么写。所以还是等彻底想好再提笔吧。<br>我以前也这样，后来发现自己真是大错特错，因为 <strong>写作可以帮助我们更好的思考</strong> 。为什么我们脑子里只想到一两点，因为我们的脑子暂时被这两点占满了。你想来想去，思路在脑子里兜圈子，怎么也绕不出这两点。<br>此时如果你写下来，把这两点「释放」到书面上，脑子放空之后自然能想到三四五点。如果把大脑比作 CPU 的话，文章就是缓存。我们把计算出的数据暂时存放在缓存中，才能更好的计算。</p>
<p>具体为什么写作能让你更好的思考，可参考这篇 <a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking" target="_blank" rel="external">书写是为了更好的思考</a> 文章。</p>
<p>综上所述，想到一点就立即动笔。我这篇在写之前，就只想到了目前篇幅的三分之一。</p>
<hr>
<p>好了，今天要说的就是这么多。另外有的童鞋说昨天的文章有种戛然而止的感觉，确实，主要是因为我在最后一段提了个问句的原因。所以今天这篇就算作昨天那个问题的补充吧。</p>
<p>欢迎关注我的公众号：haoqihaisimao_weixin</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/qrcode_for_gh_2df3b33e3297_258.jpg" alt=""></p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然是小技巧，那么就不敢班门弄斧，只简单说说自己平时遵循的几条写作原则：&lt;/p&gt;
&lt;h2 id=&quot;尽量用短句&quot;&gt;&lt;a href=&quot;#尽量用短句&quot; class=&quot;headerlink&quot; title=&quot;尽量用短句&quot;&gt;&lt;/a&gt;尽量用短句&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;写作以表达清晰为首要宗旨，所以 &lt;strong&gt;尽量用短句&lt;/strong&gt; 。长句会增加理解成本，尤其是对于中文来说。中文的定语是放在被修饰词前面的，不像英语通常放在后面，用从句很容易扩展。中文你要用从句，还 &lt;strong&gt;不如直接另起一句话&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且能一句话说清楚的，不要绕来绕去解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在句语句之间 &lt;strong&gt;多用连接词&lt;/strong&gt; ，一方面表明其联系，一方面增强连贯性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要用晦涩难懂的词&lt;/strong&gt; 。我们不是在写高考作文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对标点的使用要尽量规范。&lt;/strong&gt; 尽量少用感叹号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;文章逻辑要清晰&quot;&gt;&lt;a href=&quot;#文章逻辑要清晰&quot; class=&quot;headerlink&quot; title=&quot;文章逻辑要清晰&quot;&gt;&lt;/a&gt;文章逻辑要清晰&lt;/h2&gt;&lt;h3 id=&quot;分段、分点说明&quot;&gt;&lt;a href=&quot;#分段、分点说明&quot; class=&quot;headerlink&quot; title=&quot;分段、分点说明&quot;&gt;&lt;/a&gt;分段、分点说明&lt;/h3&gt;&lt;p&gt;众所周知，我们现在看到长篇大论的文章都难以下咽。但如果在文中加几个段落标题，效果就大大不同。&lt;br&gt;同样的，在遇到排列句的时候，每句单独成行，比一整段要清晰的多。&lt;/p&gt;
&lt;p&gt;这些措施一方面是在排版上进行改进，提升了阅读体验。更重要的一方面是这样使你的文章逻辑更加清晰。&lt;br&gt;&lt;strong&gt;写文章和做数学证明题一模一样。每一段都证明一个小问题，下一段的证明，依赖于上一段的结论。&lt;/strong&gt; 所以每段有个主题，就比胡乱写强很多。&lt;/p&gt;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="Blog" scheme="http://geekplux.com/tags/Blog/"/>
    
      <category term="Thought" scheme="http://geekplux.com/tags/Thought/"/>
    
      <category term="思考" scheme="http://geekplux.com/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="Skill" scheme="http://geekplux.com/tags/Skill/"/>
    
      <category term="Writing" scheme="http://geekplux.com/tags/Writing/"/>
    
      <category term="写文章" scheme="http://geekplux.com/tags/%E5%86%99%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>为什么文章写得好的人都很厉害</title>
    <link href="http://geekplux.com/2015/10/27/why-those-who-write-great-articles-is-so-powerful.html"/>
    <id>http://geekplux.com/2015/10/27/why-those-who-write-great-articles-is-so-powerful.html</id>
    <published>2015-10-27T14:22:22.000Z</published>
    <updated>2016-11-02T10:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先定义什么是好文章。我觉得 <strong>能让读者领悟自己想表达的</strong> 就叫好文章。换种说法就是 <strong>能达到自己写作目的</strong> 的文章就叫好文章。</p>
<p>每个人写作的目的不同，有的人抒情，有的人叙事，有的人论证，但这最终的目的都是为了 <strong>让读者理解</strong> 。即使你的目的是故弄玄虚（或者让别人猜不透自己），本质上也是让别人把你的文章解读成你想让他解读的样子。</p>
<p>所以，能写出好文章的人，具备两个重要的能力。</p>
<ul>
<li><strong>能恰如其分表达自己想法的能力</strong></li>
<li><strong>能让对方理解自己想法的能力</strong></li>
</ul>
<p>这两点看起来易如反掌，一般人也以为自己都做到了，但实际的情况是： <strong>我说的和我脑子里想的不太一样，你理解的和我说的不太一样</strong> 。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/640.jpg" alt=""></p>
<a id="more"></a>
<p>要做到第一点，首先要对自己脑子中的想法有很好的把握，其次要对文字运用的很熟练。这样写出来的文章才结构清晰，逻辑通顺，言简意赅（说白了就是简单简单再简单）。文字的运用取决于多年来对语言的积累，对想法的把握则需要多了解自己的思维方式，锻炼思维能力……我相信你也知道，我们9年义务教育都在锻炼一种叫思维能力的东西。</p>
<p>要做到第二点，则要照顾到对方的理解能力。比如很多博士写出来的论文，读者根本看不懂，因为读者无法站在和他一样的高度去理解他的文章。继而导致他的文章不流行。而有一个人，他既能理解原作者的文章，又有很好的文字功底，把原文改写的通俗易懂再发出来。大家一看就懂，于是觉得这个人很厉害。其实很多所谓的畅销书不都是这样么。</p>
<p>我觉得拥有以上两点的人基本已经无敌了。不信你可以去拜读一下我朝太祖的文章，感受一下高深哲学被解释成蕃茄鸡蛋的感觉。</p>
<p>那么如何拥有这样的能力呢？我认为写作就是最好的锻炼方式。所以这是个正循环：</p>
<blockquote>
<p>写得好-&gt;变厉害-&gt;写得更好</p>
</blockquote>
<p>从把文章写简单做起吧。</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先定义什么是好文章。我觉得 &lt;strong&gt;能让读者领悟自己想表达的&lt;/strong&gt; 就叫好文章。换种说法就是 &lt;strong&gt;能达到自己写作目的&lt;/strong&gt; 的文章就叫好文章。&lt;/p&gt;
&lt;p&gt;每个人写作的目的不同，有的人抒情，有的人叙事，有的人论证，但这最终的目的都是为了 &lt;strong&gt;让读者理解&lt;/strong&gt; 。即使你的目的是故弄玄虚（或者让别人猜不透自己），本质上也是让别人把你的文章解读成你想让他解读的样子。&lt;/p&gt;
&lt;p&gt;所以，能写出好文章的人，具备两个重要的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;能恰如其分表达自己想法的能力&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能让对方理解自己想法的能力&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两点看起来易如反掌，一般人也以为自己都做到了，但实际的情况是： &lt;strong&gt;我说的和我脑子里想的不太一样，你理解的和我说的不太一样&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/640.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Thought" scheme="http://geekplux.com/categories/Thought/"/>
    
    
      <category term="感想" scheme="http://geekplux.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="Writing" scheme="http://geekplux.com/tags/Writing/"/>
    
      <category term="写文章" scheme="http://geekplux.com/tags/%E5%86%99%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>如何管理好自己的密码</title>
    <link href="http://geekplux.com/2015/09/24/password-management.html"/>
    <id>http://geekplux.com/2015/09/24/password-management.html</id>
    <published>2015-09-24T09:08:59.000Z</published>
    <updated>2016-11-02T10:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近 Xcode Ghost 席卷三大平台，有预谋有组织有纪律。很多人看到这个消息纷纷修改常用密码，但我觉得密码管理其实功在平时，一个好的密码可以大幅提升你账户的安全系数。</p>
<p>而且，现在基本上每个网站都需要注册才能享用全部服务，我自己注册了上百个网站，意味者我有上百个账号密码需要记，用脑子记根本记不住（没办法，记忆力差）。后来我慢慢摸索出自己的一套策略用来管理密码，感觉实用且不算复杂。</p>
<h2 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h2><ol>
<li>首先要对账号和密码进行<strong>分级分类</strong>。根据重要性、产品使用频率、产品应用场景来分。我自己分为五类：银行卡类、涉及支付类、社交账号、涉及数据存储类（各种云存储、云服务等）、其他。</li>
<li>银行卡类：<strong>单独</strong>设6位数字，每张银行卡都有各自的密码（规则自己定：比如前三位是自己想的，后三位是卡号的某几位）。</li>
<li>涉及支付类：<strong>单独</strong>设密码，方法参考5、6两点。</li>
<li>社交账号类、涉及数据存储类：<strong>着重对待</strong>，方法同样参考5、6两点。</li>
<li>密码设计方法：单独想出一句话，用这句话每个字的<strong>首字母</strong>构成密码最基本的部分。大小写和符号自己<strong>有规律</strong>地加。</li>
<li><strong>排列组合</strong>：密码太多记不住很正常。可以用两组（或多组）短语排列组合成整套密码。</li>
<li>银行、涉及支付类、重度使用产品均<strong>定期更换</strong>密码。一般密码位数不低于15位（不要以为15位很长）。</li>
</ol>
<a id="more"></a>
<h2 id="密码存储"><a href="#密码存储" class="headerlink" title="密码存储"></a>密码存储</h2><p>那么密码设计出来，要存到哪里去呢？</p>
<ul>
<li><strong>全部用脑子记住</strong>。这种最安全也是最高效的方法，但是需要记忆力。</li>
<li>用 1Password, Lastpass 等密码管理软件记。我觉得这个适用于上文提到的「其他类」。</li>
<li>用文本笔记、表格记录。这个也没什么不可以，但是你一定要保存好这份文件，否则后果很严重。这里有个小技巧，你可以把密码全记录到一个 excel 文件中，然后把文件后缀改为 <code>.avi</code>，以此类推。</li>
</ul>
<p>以上就是我全部的方法了。之所以分成五类主要是因为涉及钱的账号密码，一旦泄密损失的是自己，而社交账号和数据泄密损失的是他人。</p>
<p>一般人可能会觉得自己的数据没什么价值，而且朋友们也都很机智。但是在特定情况下，你的数据会有可怕的功用。想象一下，一个人如果拥有你的绝大部分数据，同时又拥有你所有的人际关系。那么他就可以轻易的运用数据去模仿出你的样子，从而获取他人的信任。一旦获得对方的完全信任，注意，是完全信任，那对方就会沦为待宰的羔羊，任人摆布。</p>
<p>总之，密码和我们的生活息息相关，管理好自己的密码说不定还会有意外的收获：<br><a href="http://www.jianshu.com/p/a1220fd27e2f" target="_blank" rel="external">一个密码改变了我的人生</a></p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 Xcode Ghost 席卷三大平台，有预谋有组织有纪律。很多人看到这个消息纷纷修改常用密码，但我觉得密码管理其实功在平时，一个好的密码可以大幅提升你账户的安全系数。&lt;/p&gt;
&lt;p&gt;而且，现在基本上每个网站都需要注册才能享用全部服务，我自己注册了上百个网站，意味者我有上百个账号密码需要记，用脑子记根本记不住（没办法，记忆力差）。后来我慢慢摸索出自己的一套策略用来管理密码，感觉实用且不算复杂。&lt;/p&gt;
&lt;h2 id=&quot;设计方法&quot;&gt;&lt;a href=&quot;#设计方法&quot; class=&quot;headerlink&quot; title=&quot;设计方法&quot;&gt;&lt;/a&gt;设计方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先要对账号和密码进行&lt;strong&gt;分级分类&lt;/strong&gt;。根据重要性、产品使用频率、产品应用场景来分。我自己分为五类：银行卡类、涉及支付类、社交账号、涉及数据存储类（各种云存储、云服务等）、其他。&lt;/li&gt;
&lt;li&gt;银行卡类：&lt;strong&gt;单独&lt;/strong&gt;设6位数字，每张银行卡都有各自的密码（规则自己定：比如前三位是自己想的，后三位是卡号的某几位）。&lt;/li&gt;
&lt;li&gt;涉及支付类：&lt;strong&gt;单独&lt;/strong&gt;设密码，方法参考5、6两点。&lt;/li&gt;
&lt;li&gt;社交账号类、涉及数据存储类：&lt;strong&gt;着重对待&lt;/strong&gt;，方法同样参考5、6两点。&lt;/li&gt;
&lt;li&gt;密码设计方法：单独想出一句话，用这句话每个字的&lt;strong&gt;首字母&lt;/strong&gt;构成密码最基本的部分。大小写和符号自己&lt;strong&gt;有规律&lt;/strong&gt;地加。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排列组合&lt;/strong&gt;：密码太多记不住很正常。可以用两组（或多组）短语排列组合成整套密码。&lt;/li&gt;
&lt;li&gt;银行、涉及支付类、重度使用产品均&lt;strong&gt;定期更换&lt;/strong&gt;密码。一般密码位数不低于15位（不要以为15位很长）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Life" scheme="http://geekplux.com/categories/Life/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="生活" scheme="http://geekplux.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Backbone View 之间通信的三种方式</title>
    <link href="http://geekplux.com/2015/07/04/communicating-between-views-in-backbone.html"/>
    <id>http://geekplux.com/2015/07/04/communicating-between-views-in-backbone.html</id>
    <published>2015-07-04T12:49:33.000Z</published>
    <updated>2015-07-04T13:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>掌握一个 MVC 框架，最关键的一节就是掌握如何在各个 View 之间通信。之前用 Angular 时，觉得基于事件的通信方式 ($on, $emit, $boardcast) 或者 基于 service 的方式都非常好用。转战 Backbone 之后，由于对 Backbone 的事件机制理解不够且使用非常灵活，一直没找到一个好的通信方式。直到看见这篇文章，作者通过一个简单的例子，层层深入，把 Backbone View 之间通信的三种方式讲的清晰明了。译文如下（已拿到授权）：</p>
<hr>
<p>我正在开发的这个网页主要有两部分，分别是 document 和 sidebar。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/backbone-application.png" alt="Backbone Application"></p>
<p>如上图所示，我设立了三个视图 (view) :</p>
<p><code>ApplicationView</code> - 作为最外层视图来包含下级视图<br><code>DocumentView</code> - 展示正在编辑或浏览的内容<br><code>SidebarView</code> - 展示一些和 document 相关的信息</p>
<p><code>DocumentView</code> 和 <code>SidebarView</code> 作为 <code>ApplicationView</code> 的子视图，所以整体的视图结构如下图所示：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/backbone-view-structure.png" alt="Backbone View Structure"></p>
<p>用户在任意一个子视图进行操作，另一个子视图都需要随之变化。但由于两个子视图之间并不能直接通知对方（也就是说，它们的作用域没有直接联系，不像父视图，可以包含它所有子视图的作用域），所以，我需要一个事件机制。</p>
<p>在我谷歌和参考其他人的方法之后，我总结出了如下三种不同的通信方式。</p>
<a id="more"></a>
<h3 id="1-通过父视图传递事件"><a href="#1-通过父视图传递事件" class="headerlink" title="1. 通过父视图传递事件"></a>1. 通过父视图传递事件</h3><p>我通过父视图 (<code>ApplicationView</code>) 来为它的两个子视图传递事件。因为父视图包含它所有子视图的作用域，因此用它作为事件传递的媒介最好不过。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/backbone-view-event-relay.png" alt="Backbone View Event Relay"></p>
<p>JavaScript 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> ApplicationView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.documentView = <span class="keyword">new</span> DocumentView(&#123;parent:<span class="keyword">this</span>&#125;);</div><div class="line">    <span class="keyword">this</span>.sidebarView = <span class="keyword">new</span> SidebarView(&#123;parent:<span class="keyword">this</span>&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.documentView.on(<span class="string">'edit'</span>, <span class="keyword">this</span>.documentEdited, <span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  documentEdited : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// do some stuff</span></div><div class="line">    <span class="keyword">this</span>.sidebarView.trigger(<span class="string">'documentEdit'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> DocumentView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  onEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.trigger(<span class="string">'edit'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> SidebarView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.on(<span class="string">'documentEdit'</span>, <span class="keyword">this</span>.onDocumentEdit, <span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  onDocumentEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// react to document edit.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure>
<p>但是，这种方法并不高效。因为我需要在 <code>ApplicationView</code> 中添加一个额外的事件处理函数 <code>documentEdited()</code> 。如果子视图有一堆事件传过来，则在父视图中会不断触发事件处理函数，导致它不堪重负。</p>
<p>那么来看看第二种方法。</p>
<h3 id="2-通过-EventBus-在视图间通信"><a href="#2-通过-EventBus-在视图间通信" class="headerlink" title="2. 通过 EventBus 在视图间通信"></a>2. 通过 EventBus 在视图间通信</h3><p>我通过继承 <strong>Backbone.Events</strong> 来创建一个全局对象 <code>EventBus</code>。把它注入到各个子视图中，用来广播事件。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/backbone-views-event-bus.png" alt="Backbone Views Event Bus"></p>
<p>JavaScript 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> ApplicationView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.eventBus = _.extend(&#123;&#125;, Backbone.Events);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.documentView = <span class="keyword">new</span> DocumentView(&#123;</div><div class="line">      eventBus : <span class="keyword">this</span>.eventBus</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.sidebarView = <span class="keyword">new</span> SidebarView(&#123;</div><div class="line">      eventBus : <span class="keyword">this</span>.eventBus</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> DocumentView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.eventBus = options.eventBus;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  onEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.eventBus.trigger(<span class="string">'documentEdit'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> SidebarView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.eventBus = options.eventBus;</div><div class="line">    <span class="keyword">this</span>.eventBus.on(<span class="string">'documentEdit'</span>, <span class="keyword">this</span>.onDocumentEdit, <span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  onDocumentEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// react to document edit.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在这个方法中，我把 <code>EventBus</code> 作为一个全局对象用来注册事件。如果我想在各个视图之间通信，只需要在视图中注入 <code>EventBus</code>，就可以通过它方便地触发或监听事件了。</p>
<p><strong>注意</strong>：如果你不想要创建全局对象，你仍然可以创建模块 (module) 或视图 (view) 级别的 <code>EventBus</code> 用来通信。</p>
<p>这个方法已经明显优于第一种方法了。但是需要我们手动的在子视图中引入 <code>EventBus</code>，说明还有可以改进的空间，那么，来看看第三种方法。</p>
<h3 id="3-直接用-Backbone-作为事件注册机"><a href="#3-直接用-Backbone-作为事件注册机" class="headerlink" title="3. 直接用 Backbone 作为事件注册机"></a>3. 直接用 Backbone 作为事件注册机</h3><p>在第二种方法中，我创建了一个单独的 <code>EventBus</code>，继承自 <code>Backbone.Events</code>。但最近我悟到 <code>Backbone</code> 对象本身就是一个混合了 <code>Events</code> 的对象，所以我直接用 <code>Backbone</code> 广播事件，就无需单另创建的 <code>EventBus</code> 了。</p>
<p>而且 Backbone 对象可以直接调用，这样我就不必在每个子视图中手动注入它了。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/backbone-views-backbone-event-bus.png" alt="Backbone as EventBus"></p>
<p>JavaScript 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ApplicationView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.documentView = <span class="keyword">new</span> DocumentView();</div><div class="line">    <span class="keyword">this</span>.sidebarView = <span class="keyword">new</span> SidebarView();</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> DocumentView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  onEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Backbone.trigger(<span class="string">'documentEdit'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> SidebarView = Backbone.View.extend(&#123;</div><div class="line"></div><div class="line">  initialize : <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    Backbone.on(<span class="string">'documentEdit'</span>, <span class="keyword">this</span>.onDocumentEdit, <span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  onDocumentEdit : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// react to document edit.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我最终在我的项目中使用了第三种方法。而且在我看来，虽然它直接依赖了全局的 <code>Backbone</code> 对象，但是用起来却异常简洁。</p>
<p>如果有比这更好的方法，欢迎分享交流。</p>
<p>（译文完）</p>
<hr>
<p><strong>原文地址</strong>：<a href="http://veerasundar.com/blog/2013/04/communicating-between-views-in-backbone/" target="_blank" rel="external">Communicating between views in Backbone</a><br><strong>译文地址</strong>：<a href="http://www.geekplux.com/2015/07/04/communicating-between-views-in-backbone.html" target="_blank" rel="external">Backbone View 之间通信的三种方式</a></p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握一个 MVC 框架，最关键的一节就是掌握如何在各个 View 之间通信。之前用 Angular 时，觉得基于事件的通信方式 ($on, $emit, $boardcast) 或者 基于 service 的方式都非常好用。转战 Backbone 之后，由于对 Backbone 的事件机制理解不够且使用非常灵活，一直没找到一个好的通信方式。直到看见这篇文章，作者通过一个简单的例子，层层深入，把 Backbone View 之间通信的三种方式讲的清晰明了。译文如下（已拿到授权）：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我正在开发的这个网页主要有两部分，分别是 document 和 sidebar。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/backbone-application.png&quot; alt=&quot;Backbone Application&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，我设立了三个视图 (view) :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ApplicationView&lt;/code&gt; - 作为最外层视图来包含下级视图&lt;br&gt;&lt;code&gt;DocumentView&lt;/code&gt; - 展示正在编辑或浏览的内容&lt;br&gt;&lt;code&gt;SidebarView&lt;/code&gt; - 展示一些和 document 相关的信息&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DocumentView&lt;/code&gt; 和 &lt;code&gt;SidebarView&lt;/code&gt; 作为 &lt;code&gt;ApplicationView&lt;/code&gt; 的子视图，所以整体的视图结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/backbone-view-structure.png&quot; alt=&quot;Backbone View Structure&quot;&gt;&lt;/p&gt;
&lt;p&gt;用户在任意一个子视图进行操作，另一个子视图都需要随之变化。但由于两个子视图之间并不能直接通知对方（也就是说，它们的作用域没有直接联系，不像父视图，可以包含它所有子视图的作用域），所以，我需要一个事件机制。&lt;/p&gt;
&lt;p&gt;在我谷歌和参考其他人的方法之后，我总结出了如下三种不同的通信方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://geekplux.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://geekplux.com/tags/Web/"/>
    
      <category term="译文" scheme="http://geekplux.com/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="Translation" scheme="http://geekplux.com/tags/Translation/"/>
    
      <category term="Backbone" scheme="http://geekplux.com/tags/Backbone/"/>
    
  </entry>
  
  <entry>
    <title>Vim - 适合自己的，才是最好的</title>
    <link href="http://geekplux.com/2015/06/06/vim-those-fit-yourself-are-the-best.html"/>
    <id>http://geekplux.com/2015/06/06/vim-those-fit-yourself-are-the-best.html</id>
    <published>2015-06-06T12:28:21.000Z</published>
    <updated>2016-12-03T10:13:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 被称为编辑器之神，是我用过之后才体会到的，用之前实在不敢对它做出什么评价。在大学时代，Vim 的大名就已如雷贯耳，但由于它陡峭的学习曲线，一直望而却步。等真正开始学习之后，发现并没有想象中的复杂，也没有所谓的瓶颈，只要在实际写代码中强迫自己使用就可以了，无形中就会形成习惯。最初的不适，换来的是效率的飞升。这和我当初学习<a href="http://www.geekplux.com/2014/07/06/learn_shuangpin.html" target="_blank" rel="external">双拼</a>的感觉一样。下图是我的 Vim 界面：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/vim.png" alt="我的 Vim 界面"></p>
<h2 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h2><p>我一开始也是看了很多教程，这里我就不说具体的学习方法了，因为 Google 上一搜一大堆。</p>
<p>我只想谈一点：很多「过来人」告诫新手，一开始使用 Vim 一定不能使用插件，<strong>要从最纯净的 Vim 开始练习</strong>。他们认为一上手就使用别人的配置，很容易被别人影响，不能领会到自己配置 Vim，这种从无到有的感觉。虽然我也很喜欢折腾的感觉，但这对于学习、入门一个工具来说有点<strong>南辕北辙</strong>，我们学习一个工具就是为了用好它，或者<strong>用它来为我们服务</strong>。为什么要我们去适应它呢？也许这不符合 Vim 的哲学，但是我觉得：</p>
<ul>
<li>Vim 存在这么多年，已经有很多优秀的 Vim 配置（比如：<a href="https://github.com/spf13/spf13-vim" target="_blank" rel="external">spf13-vim</a>），可以为我们节省很多折腾的时间。不过如果你非常喜欢折（zuo）腾（si），那也可以从头开始。</li>
<li>对于新手来说，自己的配置总是很不成熟，到头来还是得参考一些高手的配置。索性一开始用他们的，慢慢删改。</li>
<li>从纯净版开始你会觉得很枯燥，Vim 远没别人口中、视频中所述的酷炫，效率不升反降。这很容易丧失进阶的兴趣。</li>
<li>天下武功，唯快不破，这个时代求快。我不否认先夯实基础，再层层递进的学习方式，但针对不同的学习对象，不同的环境背景，我们还是应该采取最快、最有效的学习方式。</li>
</ul>
<a id="more"></a>
<p>如果你学习 Vim 是为了体验学习的新鲜感，或者业余玩味，请忽略我上面的话。但如果你的最终目的是为了在实际中用到它，提升我们的工作效率，那你不妨和我一样，直接拉别人的配置下来，在 Shell 里输入 Vim 启动，开始写代码！</p>
<p>当时我找到了 <a href="https://github.com/wklken/k-vim" target="_blank" rel="external">k-vim</a>，按照他的安装步骤，很简单就把 Vim 配置好了，启动 Vim，发现界面也很漂亮，嗯，这就是我要的效果。接着，我打开自己那两天正在写的项目，通过仅会的四个快捷键 <strong>HJKL</strong> 移动光标来查看文件。然后我仔细阅读了 <a href="https://github.com/wklken/k-vim" target="_blank" rel="external">k-vim</a> 的 README 文件，把它提到的几个快捷键试了试，感觉很不错。接下来的几天，它的 README 网页我一直开着，遇到想要的快捷键一搜就搞定，虽然写代码的效率确实下降了很多，但对编辑器的使用越来越纯熟。一周之后我已经习惯用 Vim 来编程了。</p>
<p>接下来开始进一步研究 Vim，理解 Vim  的<strong>三种模式</strong>（正常模式、命令模式、视图模式），然后掌握如何配置<strong>插件</strong>和<strong>快捷键</strong>就OK了。最关键一点就是要实战，强迫自己所有的操作只用键盘，强迫只用 Vim 作编辑器。</p>
<h2 id="插件与快捷键"><a href="#插件与快捷键" class="headerlink" title="插件与快捷键"></a>插件与快捷键</h2><p>Vim 的插件可以通过 <a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="external">Vundle</a> 来管理。（据说 <a href="https://github.com/junegunn/vim-plug" target="_blank" rel="external">vim-plug</a> 也挺好用）</p>
<p>只需两步：</p>
<ul>
<li>在 <code>vimrc.bundles</code> 文件中配置你想要的插件</li>
<li>在 Vim 的命令模式中输入<code>:BundleInstall</code></li>
</ul>
<p>其他的命令有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:BundleUpdate    //更新插件</div><div class="line">:BundleClean     //删除插件</div></pre></td></tr></table></figure>
<p>个人觉得必备的插件：</p>
<ul>
<li>syntastic 多语言语法检查</li>
<li>YouCompleteMe 代码自动补全</li>
<li>ctrlp.vim 文件搜索，类似 Sublime Text 里面的 Cmd + P</li>
<li>vim-airline 状态栏增强</li>
<li>nerdtree目录树</li>
<li>vim-ctrlspace tab/buffer导航增强</li>
</ul>
<p>而快捷键的学习方法，就是用到的时候去 Google，多用几次就记住了。如果它自带的快捷键用着不舒服，你完全可以自己重设，Vim 就是自由，不必拘泥条条框框。</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>非常推荐阅读 Stack Overflow 上的这篇回答：</p>
<p><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim" target="_blank" rel="external">What is your most productive shortcut with Vim?</a></p>
<p>这篇真正阐述了 Vim 作者当初设计 Vim 快捷键时的哲学，看懂这篇对 Vim 快捷键的掌握会更上一层。</p>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>在学习 Vim、使用 Vim 的过程中，我最大的感悟就是<strong>「适合自己的，才是最好的」</strong>。</p>
<p>很多插件看起来很酷炫，快捷键几下就能实现很繁杂的操作，但是你不一定会有使用这个插件的需求，或者即使用也用的不多。有人总喜欢拿 IDE 和 Vim 比，我觉得这根本没有比较的必要，你两个都用也没什么问题。大的项目，复杂的文件结构和引用，你不用 IDE 而用 Vim，是浪费时间。而且一般 IDE 都提供了 Vim 模式，你仍可以在 IDE 中继续击键如飞。</p>
<p>用 Vim 体验的是一种<strong>轻便、自由、可塑</strong>的感觉。你可以根据自己的需求来培养 Vim，这就像恋（gao）爱（ji）一样是两个人互相适应的过程。互相习惯才能把效率最大化。</p>
<hr>
<h3 id="推荐链接"><a href="#推荐链接" class="headerlink" title="推荐链接"></a>推荐链接</h3><ul>
<li><a href="http://vim-adventures.com/" target="_blank" rel="external">Vim Adventure</a>  Vim 小游戏</li>
<li><a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">Learn Vim Progressively</a> 中文版：<a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="external">简明 Vim 练级攻略</a></li>
<li><a href="http://learnvimscriptthehardway.stevelosh.com/" target="_blank" rel="external">Learn Vimscript the Hard Way</a> 中文版：<a href="http://learnvimscriptthehardway.onefloweroneworld.com/" target="_blank" rel="external">笨方法学Vimscript</a></li>
<li><a href="http://www.openvim.com/tutorial.html" target="_blank" rel="external">交互式学习 Vim</a></li>
<li><a href="http://vimawesome.com/" target="_blank" rel="external">Vim Awesome</a> Awesome Vim plugins from across the universe</li>
<li><a href="http://cenalulu.github.io/linux/all-vim-cheatsheat/" target="_blank" rel="external">史上最全Vim快捷键键位图 – 入门到进阶</a></li>
<li><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="external">所需即所获：像 IDE 一样使用 vim</a></li>
<li><a href="http://yuez.me/jiang-ni-de-vim-da-zao-cheng-qing-qiao-qiang-da-de-ide/" target="_blank" rel="external">将你的Vim 打造成轻巧强大的IDE</a></li>
</ul>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim 被称为编辑器之神，是我用过之后才体会到的，用之前实在不敢对它做出什么评价。在大学时代，Vim 的大名就已如雷贯耳，但由于它陡峭的学习曲线，一直望而却步。等真正开始学习之后，发现并没有想象中的复杂，也没有所谓的瓶颈，只要在实际写代码中强迫自己使用就可以了，无形中就会形成习惯。最初的不适，换来的是效率的飞升。这和我当初学习&lt;a href=&quot;http://www.geekplux.com/2014/07/06/learn_shuangpin.html&quot;&gt;双拼&lt;/a&gt;的感觉一样。下图是我的 Vim 界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/vim.png&quot; alt=&quot;我的 Vim 界面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习方式&quot;&gt;&lt;a href=&quot;#学习方式&quot; class=&quot;headerlink&quot; title=&quot;学习方式&quot;&gt;&lt;/a&gt;学习方式&lt;/h2&gt;&lt;p&gt;我一开始也是看了很多教程，这里我就不说具体的学习方法了，因为 Google 上一搜一大堆。&lt;/p&gt;
&lt;p&gt;我只想谈一点：很多「过来人」告诫新手，一开始使用 Vim 一定不能使用插件，&lt;strong&gt;要从最纯净的 Vim 开始练习&lt;/strong&gt;。他们认为一上手就使用别人的配置，很容易被别人影响，不能领会到自己配置 Vim，这种从无到有的感觉。虽然我也很喜欢折腾的感觉，但这对于学习、入门一个工具来说有点&lt;strong&gt;南辕北辙&lt;/strong&gt;，我们学习一个工具就是为了用好它，或者&lt;strong&gt;用它来为我们服务&lt;/strong&gt;。为什么要我们去适应它呢？也许这不符合 Vim 的哲学，但是我觉得：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vim 存在这么多年，已经有很多优秀的 Vim 配置（比如：&lt;a href=&quot;https://github.com/spf13/spf13-vim&quot;&gt;spf13-vim&lt;/a&gt;），可以为我们节省很多折腾的时间。不过如果你非常喜欢折（zuo）腾（si），那也可以从头开始。&lt;/li&gt;
&lt;li&gt;对于新手来说，自己的配置总是很不成熟，到头来还是得参考一些高手的配置。索性一开始用他们的，慢慢删改。&lt;/li&gt;
&lt;li&gt;从纯净版开始你会觉得很枯燥，Vim 远没别人口中、视频中所述的酷炫，效率不升反降。这很容易丧失进阶的兴趣。&lt;/li&gt;
&lt;li&gt;天下武功，唯快不破，这个时代求快。我不否认先夯实基础，再层层递进的学习方式，但针对不同的学习对象，不同的环境背景，我们还是应该采取最快、最有效的学习方式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://geekplux.com/categories/Tool/"/>
    
    
      <category term="Tool" scheme="http://geekplux.com/tags/Tool/"/>
    
      <category term="工具" scheme="http://geekplux.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Vim" scheme="http://geekplux.com/tags/Vim/"/>
    
      <category term="Emacs" scheme="http://geekplux.com/tags/Emacs/"/>
    
      <category term="IDE" scheme="http://geekplux.com/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>轻松玩转 Ukulele</title>
    <link href="http://geekplux.com/2015/01/05/play-ukulele.html"/>
    <id>http://geekplux.com/2015/01/05/play-ukulele.html</id>
    <published>2015-01-05T15:54:00.000Z</published>
    <updated>2017-06-20T02:19:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个人都幻想过自己拥有一身的艺术细菌，可以像各种钢琴王子一样在琴键上挥洒自如。但是由于某些不可抗力，从小到大一直没学什么乐器，或者是学了也没坚持下来。最尴尬的是选了一种鸡肋乐器，学有所成却不接地气，比如二胡（我真不是黑，因为我也学过那么两年），总不能在同学聚会激战正酣的时候拿出来即兴演奏吧……还是老老实实戴个圆框墨镜到地铁口来一曲二泉映月……</p>
<p>人生苦短，为了圆我们的音（zhuang）乐（bi）梦，Ukulele 可以说是应运而生。本文将从 what、why、how 三方面介绍如何快速玩转 Ukulele，争取把我在学习过程中遇到的坑都写出来供大家参考。</p>
<h2 id="What-什么是-Ukulele"><a href="#What-什么是-Ukulele" class="headerlink" title="What-什么是 Ukulele"></a>What-什么是 Ukulele</h2><p>Ukulele 翻译为夏威夷吉他、四弦琴，音译为乌克丽丽、悠可力力、尤克里里、优可乐乐，简称 Uku、Uke……没错，这么多名字都是在说一个玩意。不要纠结到底中文叫那个名字合适，你直接用 Ukulele 一词以蔽之。</p>
<p>它是一种弦乐器，正常情况下长这样：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/1.jpg" alt="正常的 Ukulele（图片来自网络）"></p>
<p>不正常情况下长这样：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/2.jpeg" alt="不正常的 Ukulele（图片来自网络）"></p>
<p>还有各种奇形怪状的，都非常可爱。从图上可以看出它整体和吉他非常类似，唯一的不同是少了两根弦，这就大大降低了学习成本！而且它音色清脆入耳，弹起来节奏活泼畅快，可以说是居家旅行必备之良品。如果对它的起源或背景感兴趣，可以去<a href="http://baike.baidu.com/subview/3963326/10243259.htm" target="_blank" rel="external">百度百科-乌克丽丽</a>了解一下。</p>
<a id="more"></a>
<h2 id="Why-为什么要玩-Ukulele"><a href="#Why-为什么要玩-Ukulele" class="headerlink" title="Why-为什么要玩 Ukulele"></a>Why-为什么要玩 Ukulele</h2><ul>
<li><p><strong>无入门门坎，学习成本极低</strong><br>只要10分钟，就可以弹出一首完整的曲子。如果你会吉他，更是拿起来就能弹。比吉他少了两根弦，学习成本直线下降，而其演奏效果却还和吉他差不多。不需要学习乐理，也不用系统学习，想唱啥歌，找个谱子开练即可。很多小正太小萝莉都能学得会，你当然不在话下。俗话说欲速则不达，Ukulele 却是真心可以速成的。</p>
</li>
<li><p><strong>对手指友好</strong><br>绝大多数 Ukulele 的弦是尼龙弦，按起来不疼，对手指特别友好。不像吉他那么难按，弹十分钟手指就疼的受不了。当然，等你练个一星期，就会发现指头上多了一层茧，怎么按都不会疼。</p>
</li>
<li><p><strong>小巧便携，各种场合都能来一手</strong><br>小巧也是针对吉他来说的，一个胳膊就能夹住，背个小包也根本不费事。同学聚餐来一首调动气氛；草坪边上来一曲深情款款；公司年会来一首技惊四座；调试代码的间隙也可以来一首陶冶情操；马路边，地铁口，放个碗……</p>
</li>
<li><p><strong>小清新，高逼格</strong><br>基本上文艺青年看见 Ukulele 就走不动道了。妹子们弹是这样的：<br><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/3.jpg" alt="妹纸弹 Uku（图片来自网络）"><br>也可能是这样的：<br><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/4.jpg" alt="Taylor Swift 弹唱会弹 Uku（图片来自网络）"><br>男青年的样子是这样的：<br><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/5.jpg" alt="大叔弹 Uku（图片来自网络）"><br>哈哈，是不是如沐春风！可装逼可接地气，更是勾搭文（wu）艺（zhi）女青年的神器。</p>
</li>
</ul>
<ul>
<li><strong>有趣！好玩！</strong><br>喜欢一件事物，必然是因为它有趣啊！我在认识 Ukulele 之后才知道它多有趣，不止是弹情歌，比如下面这位大牛（现在他已经长大了！）。别问我他弹的什么，你听了前三秒就知道！</li>
</ul>
<div class="video-container"><iframe src="http://player.youku.com/embed/XMjk2OTI3MjEy" frameborder="0" allowfullscreen></iframe></div>
<h2 id="How-怎么快速玩转-Ukulele"><a href="#How-怎么快速玩转-Ukulele" class="headerlink" title="How-怎么快速玩转 Ukulele"></a>How-怎么快速玩转 Ukulele</h2><p>我当初是在上司的勾引下，入了这个坑的。把玩了他的琴两天，实在是爱不释手，就迫不及待地也入了一把，从此人生又多了一些欢乐，哈哈。以下从我的经历来说说怎么快速上手：</p>
<h3 id="1-你要有把琴"><a href="#1-你要有把琴" class="headerlink" title="1.你要有把琴"></a>1.你要有把琴</h3><p>市面上的 Ukulele 可以分为三种：高音（Soprano）、中音（Concert）、次中音（Tenor），分别简称 S 型、C 型、T 型。其实还有一种 B 型，但是由于音太低，新手不宜考虑。</p>
<p>S 型最小，琴身长 21 寸，音色最为清亮。可以给小盆友买用来玩耍，个子小的萌妹子也可以用。不过由于它比较小，所以适合弹唱，而不适合指弹（弹唱就是边弹边唱，指弹就是只弹不唱）。</p>
<p>C 型适中，琴身长 23寸，指弹和弹唱都可以，女生非常适合这款，男生你得考虑下身高，个子高而用这把显得不是很协调。</p>
<p>T 型最长，琴身长26寸，音色稍低，大部分男生选这款。</p>
<p>我觉得新手可以只考虑型号就好了，剩下的共鸣、音准、琴弦、琴身材质等可以等进阶的时候再买。至于价钱，某宝上价格参差不齐，不过我建议<strong>买个在你承受范围内偏贵那么一小点的</strong>，这样你一方面会好好珍惜它，多练习，另一方面音色好弹出来的效果就好，容易有成就感，有成就感就会坚持下来。</p>
<h3 id="2-你得学会调音"><a href="#2-你得学会调音" class="headerlink" title="2.你得学会调音"></a>2.你得学会调音</h3><p>调音就是把每根弦的音调（diao）调（tiao）到它该发的调（diao）上。由于 Ukulele 的弦是尼龙弦而不是金属弦，所以弹着弹着容易音不准，要经常调校，有完美强迫症的人每次弹之前估计都得调一下。</p>
<p>我是在某宝入的琴，店家送了调音器。把调音器夹在琴头上，然后依次波动每个琴弦，观察调音器上的音阶字母对应正确且显示为绿色即可。看这个视频一下就懂了：</p>
<div class="video-container"><iframe src="http://player.youku.com/embed/XNDQ1NTgxNjg4" frameborder="0" allowfullscreen></iframe></div>
<div class="video-container"><embed "415"="" "544"="" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=11414990&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></div>
<embed height="415" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="//static.hdslb.com/miniloader.swf" flashvars="aid=11414990&page=1" pluginspage="//www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash">

<p>是不是非常简单∩_∩</p>
<h3 id="3-姿势"><a href="#3-姿势" class="headerlink" title="3.姿势"></a>3.姿势</h3><p>Ukulele 小巧可爱，怎么抱着都能弹，你可以坐着弹，躺着弹，站着弹。<strong>但是越到后面越觉得姿势非常重要</strong>。基本的持琴姿势是这样的：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/9.png" alt="持琴方法（图片来自《最易上手尤克里里弹唱超精选》）"></p>
<p>用右肘的内侧来夹住琴，让它在弹奏过程中不要乱跑，但又不能让你的右手失去灵活，总之这里需要一个巧劲，慢慢摸索。<br>左手也分两种，一种是用虎口托住琴，一种是虎口那悬空。如图：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/10.png" alt="左手姿势（图片来自《最易上手尤克里里弹唱超精选》）"></p>
<p>以上左右手的姿势中的要点都是我的亲身体会，其他的地方，如按弦方法，是指肚按弦还是指尖按弦（推荐指尖），我觉得问题不大，怎么舒服怎么来。</p>
<p>按弦的样子可以参考这张：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/13.jpg" alt="按弦姿势（图片来自网络）"></p>
<p><strong>但我在练习过程中还遇到了一个大坑：</strong>那就是用拇指拨4弦或3弦时，总会碰到另一根。困扰了我很久，直到看到网上的这张图片：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/11.jpg" alt="错误的右手姿势（图片来自网络）"></p>
<p>虽然这是吉他的右手，但对 Uku 同样适用。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/12.jpg" alt="正确的右手姿势（图片来自网络）"></p>
<p>所以<strong>一开始最好力求姿势准确</strong>，可以避免后来的很多坑。为什么姿势很重要可以看看知乎上<a href="http://www.zhihu.com/question/23935947/answer/26247357" target="_blank" rel="external">如何快速地自学 Ukulele？</a>（这个问题也是我当初提的）。</p>
<h3 id="4-无敌四和弦"><a href="#4-无敌四和弦" class="headerlink" title="4.无敌四和弦"></a>4.无敌四和弦</h3><p>和弦是啥？一般人玩一个乐器，第一句肯定问：这个哆在哪？ 没错，和弦就可以看作是哆唻咪等音符的组合，左手按住和弦，右手拨琴弦就会发出悦耳的声音了。我们的目的是快速上手，快速演奏出想唱的歌，所以这些细节没必要一开始搞懂，等学到瓶颈再来深入。</p>
<p><strong>C  Am  F  G7</strong> 这四个和弦被称为无敌四和弦。之所以无敌，是因为掌握了它们就可以演奏很多歌曲，不信你去搜关键字「Ukulele 无敌四和弦」，就可以看到很多曲谱。其指法如下：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/7.jpg" alt="无敌四和弦（图片来自网络）"></p>
<p>另外 <strong>G</strong> 和弦也是经常用，它和 <strong>G7</strong> 听起来差不多，所以前期如果按 <strong>G</strong> 吃力，就先用 <strong>G7</strong> 代替。我当初按 <strong>G</strong> 无名指怎么也够不着T_T，练了好久才习惯自如……总之，先用左手把这四个和弦练熟。</p>
<p>接下来可以看一下主要的和弦图（不要怕，如果是弹唱则一首歌用到的很少）：</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/8.jpg" alt="主要和弦图（图片来自网络）"></p>
<h3 id="5-节奏型与扫弦"><a href="#5-节奏型与扫弦" class="headerlink" title="5.节奏型与扫弦"></a>5.节奏型与扫弦</h3><p>啥又是节奏型？其实就是节奏，动次打次，或者动动次打动打。。还是没必要搞懂它，我们每个人都会打拍子，除非是完全没乐感。会打拍子就可以直接来弹比较简单的节奏型。</p>
<p>那右手怎么弹呢？答案并不是像吉他那样所有指头都上，而是<strong>一指禅</strong>！没错，只用食指！上下扫就行了！</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/14.png" alt="一指禅（图片来自《最易上手尤克里里弹唱超精选》）"></p>
<p>知道如何扫弦，就可以来学习简单的节奏型了。我推荐新手看这位张松涛老师的视频，我就是看他的第五课学会了第一首歌《莫名我就喜欢你》：</p>
<div class="video-container"><iframe src="http://player.youku.com/embed/XMzE2NjgzNjg4" frameborder="0" allowfullscreen></iframe></div>
<p>接着看第六课把《You Are My Sunshine》学会（两首都是一样的最简单下下下下四拍和弦），基本上就可以宣告你的 Ukulele 旅程要开始了！</p>
<p>非常推荐 <a href="http://v.youku.com/v_show/id_XNzU4MzA5NDYw.html" target="_blank" rel="external">这个系列视频</a>，介绍了17个常用节奏型，你到后期肯定会用到。</p>
<h3 id="6-练"><a href="#6-练" class="headerlink" title="6.练"></a>6.练</h3><p>入门之后，你要做的就一个字：练！吃完饭练，Debug 期间练，起床之后练，无时不刻在练。你要找那种你特别想学会弹唱的曲子，这样学着会特别有动力，不一段时间你就会突飞猛进。如果你是偏向指弹的，那就不像弹唱这么简单了，弹唱可以用嗓音把你弹奏的瑕疵遮盖掉，而指弹单纯的靠拨弦发音，所以一首歌得无数次。</p>
<p>我一般习惯浏览以下资源：</p>
<ul>
<li><a href="http://www.zhihu.com/question/23935947" target="_blank" rel="external">如何快速地自学 Ukulele？</a>这个是我当初在知乎提的问题，里面妹纸回答的很不错。</li>
<li>我还买了《最易上手尤克里里弹唱超精选》这本书，不过感觉帮助不大，全是曲谱……</li>
</ul>
<p><strong>教程和曲谱：</strong></p>
<ul>
<li><a href="http://www.ukulelecn.com/forum.php" target="_blank" rel="external">Ukulelecn</a></li>
<li><a href="http://www.ukulelefan.com/" target="_blank" rel="external">尤克里里 Fans</a></li>
</ul>
<p><strong>视频：</strong></p>
<ul>
<li>不得不提的 <a href="http://i.youku.com/shushuMa" target="_blank" rel="external">马叔叔</a></li>
<li>刚才提到的 <a href="http://i.youku.com/ukulele" target="_blank" rel="external">优客伙计</a></li>
<li><a href="http://i.youku.com/u/UNjI1NDI5NTEy" target="_blank" rel="external">广州弹吧小吉他教室</a></li>
<li><a href="http://i.youku.com/zixunyq" target="_blank" rel="external">子熏乐器张SIR</a> 张 sir 很帅</li>
<li><a href="http://i.youku.com/ukulelemm" target="_blank" rel="external">maixueguonian</a></li>
</ul>
<p>最后你可以膜拜一下公认的大神 <a href="http://baike.baidu.com/view/6195265.htm" target="_blank" rel="external">Jake Shimabukuro</a>，听过他的<a href="http://www.zhihu.com/question/20457612" target="_blank" rel="external">弹奏</a>才知道 Ukulele 也能玩到这种境界。</p>
<p><img src="http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/6.jpg" alt="Jake Shimabukuro（图片来自网络）"></p>
<h2 id="从玩-Ukulele-中学到的"><a href="#从玩-Ukulele-中学到的" class="headerlink" title="从玩 Ukulele 中学到的"></a>从玩 Ukulele 中学到的</h2><ol>
<li>学一样东西的时候应该简单粗暴，掌握大体方向而不拘泥细节，直接实践做出效果，然后再从中找不足，查漏补缺，研究细枝末节。</li>
<li>难是因为没有开始，开始了就不会难。</li>
<li>学习新的技能，会为你的生活打开一扇窗。</li>
<li>对于兴趣，一天进步一点点就好，没必要贪多，也不求速成。长年累月的积累会让量变达到质变。</li>
<li>菜鸟有菜鸟的乐趣。</li>
</ol>
<p>虽然网上已经有很多入门教程了，但仍希望这篇文章能给你些许的帮助，谢谢:)</p>
<hr>
<p>本作品采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">知识共享 署名-非商业性使用-禁止演绎 4.0 国际 许可协议</a>进行许可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个人都幻想过自己拥有一身的艺术细菌，可以像各种钢琴王子一样在琴键上挥洒自如。但是由于某些不可抗力，从小到大一直没学什么乐器，或者是学了也没坚持下来。最尴尬的是选了一种鸡肋乐器，学有所成却不接地气，比如二胡（我真不是黑，因为我也学过那么两年），总不能在同学聚会激战正酣的时候拿出来即兴演奏吧……还是老老实实戴个圆框墨镜到地铁口来一曲二泉映月……&lt;/p&gt;
&lt;p&gt;人生苦短，为了圆我们的音（zhuang）乐（bi）梦，Ukulele 可以说是应运而生。本文将从 what、why、how 三方面介绍如何快速玩转 Ukulele，争取把我在学习过程中遇到的坑都写出来供大家参考。&lt;/p&gt;
&lt;h2 id=&quot;What-什么是-Ukulele&quot;&gt;&lt;a href=&quot;#What-什么是-Ukulele&quot; class=&quot;headerlink&quot; title=&quot;What-什么是 Ukulele&quot;&gt;&lt;/a&gt;What-什么是 Ukulele&lt;/h2&gt;&lt;p&gt;Ukulele 翻译为夏威夷吉他、四弦琴，音译为乌克丽丽、悠可力力、尤克里里、优可乐乐，简称 Uku、Uke……没错，这么多名字都是在说一个玩意。不要纠结到底中文叫那个名字合适，你直接用 Ukulele 一词以蔽之。&lt;/p&gt;
&lt;p&gt;它是一种弦乐器，正常情况下长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/1.jpg&quot; alt=&quot;正常的 Ukulele（图片来自网络）&quot;&gt;&lt;/p&gt;
&lt;p&gt;不正常情况下长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7b1evr.com1.z0.glb.clouddn.com/illustration/play-ukulele/2.jpeg&quot; alt=&quot;不正常的 Ukulele（图片来自网络）&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有各种奇形怪状的，都非常可爱。从图上可以看出它整体和吉他非常类似，唯一的不同是少了两根弦，这就大大降低了学习成本！而且它音色清脆入耳，弹起来节奏活泼畅快，可以说是居家旅行必备之良品。如果对它的起源或背景感兴趣，可以去&lt;a href=&quot;http://baike.baidu.com/subview/3963326/10243259.htm&quot;&gt;百度百科-乌克丽丽&lt;/a&gt;了解一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Ukulele" scheme="http://geekplux.com/categories/Ukulele/"/>
    
    
      <category term="新技能" scheme="http://geekplux.com/tags/%E6%96%B0%E6%8A%80%E8%83%BD/"/>
    
      <category term="Skill" scheme="http://geekplux.com/tags/Skill/"/>
    
      <category term="乐器" scheme="http://geekplux.com/tags/%E4%B9%90%E5%99%A8/"/>
    
      <category term="Instrument" scheme="http://geekplux.com/tags/Instrument/"/>
    
      <category term="Ukulele" scheme="http://geekplux.com/tags/Ukulele/"/>
    
  </entry>
  
</feed>
